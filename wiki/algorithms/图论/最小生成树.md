## 一、**最小生成树（MST）的基本概念**
### 1. **带权图（Weighted Graph）**
- 图 $G=(V,E)$，每条边 $e$ 有一个权重 $w(e)$。
- 权重通常表示距离、代价、长度等。

### 2. **生成树（Spanning Tree）**
- 是 $G$ 的一个**子图**，是**树**（无环连通图），且包含 $G$ 的所有顶点。
- 若 $G$ 有 $n$ 个顶点，则生成树恰好有 $n-1$ 条边。

### 3. **最小生成树（Minimum Spanning Tree）**
- 所有生成树中**总权重最小**的那一个。
- **应用场景**：如连接所有计算机的最短电缆长度问题。

---

## 二、**MST 的关键性质**
### **命题 14.25（Cut Property）**
- 将顶点集 $V$ 划分为两个非空子集 $V_1$ 和 $V_2$。
- 在所有连接 $V_1$ 和 $V_2$ 的边中，权重最小的那条边 $e$ 一定属于**某个 MST**。
- **推论**：只要按“连接两个不同连通块的最小边”这样的规则选边，一定能得到 MST。

### **其他性质**
- 如果所有边权不同，则 MST **唯一**。
- 即使存在负权边或负权环，命题 14.25 仍然成立。

## Kruskal 算法[](https://oi-wiki.org/graph/mst/#kruskal-%E7%AE%97%E6%B3%95 "Permanent link")

Kruskal 算法是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。

### 前置知识[](https://oi-wiki.org/graph/mst/#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86 "Permanent link")

[并查集](https://oi-wiki.org/ds/dsu/)、[贪心](https://oi-wiki.org/basic/greedy/)、[图的存储](https://oi-wiki.org/graph/save/)。

### 实现[](https://oi-wiki.org/graph/mst/#%E5%AE%9E%E7%8E%B0 "Permanent link")

图示：

![](https://oi-wiki.org/graph/images/mst-2.apng)

伪代码：

$$
\begin{aligned}
1 & \quad \textbf{Input. } \text{The edges of the graph } e , \text{ where each element in } e \text{ is } (u, v, w) \\
& \quad \text{ denoting that there is an edge between } u \text{ and } v \text{ weighted } w . \\
2 & \quad \textbf{Output. } \text{The edges of the MST of the input graph}.\\
3 & \quad \textbf{Method. } \\ 
4 & \quad result \gets \varnothing \\
5 & \quad \text{sort } e \text{ into nondecreasing order by weight } w \\ 
6 & \quad \textbf{for } \text{each } (u, v, w) \text{ in the sorted } e \\ 
7 & \quad\qquad \textbf{if } u \text{ and } v \text{ are not connected in the union-find set } \\
8 & \quad\qquad\qquad \text{connect } u \text{ and } v \text{ in the union-find set} \\
9 & \quad\qquad\qquad  result \gets result\;\bigcup\ \{(u, v, w)\} \\
10&\quad \textbf{return }  result
\end{aligned}
$$

算法虽简单，但需要相应的数据结构来支持……具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。

抽象一点地说，维护一堆 **集合**，查询两个元素是否属于同一集合，合并两个集合。

其中，查询两点是否连通和连接两点可以使用并查集维护。

如果使用 𝑂(𝑚log⁡𝑚)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(m\log m)") 的排序算法，并且使用 𝑂(𝑚𝛼(𝑚,𝑛))![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(m\alpha(m, n))") 或 𝑂(𝑚log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(m\log n)") 的并查集，就可以得到时间复杂度为 𝑂(𝑚log⁡𝑚)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(m\log m)") 的 Kruskal 算法。

### 证明[](https://oi-wiki.org/graph/mst/#%E8%AF%81%E6%98%8E "Permanent link")

思路很简单，为了造出一棵最小生成树，我们从最小边权的边开始，按边权从小到大依次加入，如果某次加边产生了环，就扔掉这条边，直到加入了 𝑛 −1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "n-1") 条边，即形成了一棵树。

证明：使用归纳法，证明任何时候 K 算法选择的边集都被某棵 MST 所包含。

基础：对于算法刚开始时，显然成立（最小生成树存在）。

归纳：假设某时刻成立，当前边集为 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F")，令 𝑇![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T") 为这棵 MST，考虑下一条加入的边 𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "e")。

如果 𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "e") 属于 𝑇![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T")，那么成立。

否则，𝑇 +𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T+e") 一定存在一个环，考虑这个环上不属于 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F") 的另一条边 𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "f")（至少存在一条）。

首先，𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "f") 的权值一定不会比 𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "e") 小，不然 𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "f") 会在 𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "e") 之前被选取。

然后，𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "f") 的权值一定不会比 𝑒![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "e") 大，不然 𝑇 +𝑒 −𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T+e-f") 就是一棵比 𝑇![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T") 还优的生成树了。

所以，𝑇 +𝑒 −𝑓![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T+e-f") 包含了 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F")，并且也是一棵最小生成树，归纳成立。

## Prim 算法[](https://oi-wiki.org/graph/mst/#prim-%E7%AE%97%E6%B3%95 "Permanent link")

Prim 算法是另一种常见并且好写的最小生成树算法。该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。

### 实现[](https://oi-wiki.org/graph/mst/#%E5%AE%9E%E7%8E%B0_1 "Permanent link")

图示：

![](https://oi-wiki.org/graph/images/mst-3.apng)

具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。

其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 𝑂(1)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(1)") decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 **不一定** 实际跑得更快。

暴力：𝑂(𝑛2 +𝑚)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n^2+m)")。

二叉堆：𝑂((𝑛 +𝑚)log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O((n+m) \log n)")。

Fib 堆：𝑂(𝑛log⁡𝑛 +𝑚)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n \log n + m)")。

伪代码：
$$
\begin{aligned}
1 &  \textbf{Input. } \text{The nodes of the graph }V\text{ ; the function }g(u, v)\text{ which}\\
&  \text{means the weight of the edge }(u, v)\text{; the function }adj(v)\text{ which}\\
&  \text{means the nodes adjacent to }v.\\
2 &  \textbf{Output. } \text{The sum of weights of the MST of the input graph.} \\
3 &  \textbf{Method.} \\
4 &  result \gets 0 \\
5 & \text{choose an arbitrary node in }V\text{ to be the }root \\
6 &  dis(root)\gets 0 \\
7 &  \textbf{for } \text{each node }v\in(V-\{root\}) \\
8 &  \qquad  dis(v)\gets\infty \\
9 &  rest\gets V \\
10 &  \textbf{while }  rest\ne\varnothing \\
11 &  \qquad cur\gets \text{the node with the minimum }dis\text{ in }rest \\
12 &  \qquad  result\gets result+dis(cur) \\
13 &  \qquad  rest\gets rest-\{cur\} \\
14 &  \qquad  \textbf{for}\text{ each node }v\in adj(cur) \\
15 &  \qquad\qquad  dis(v)\gets\min(dis(v), g(cur, v)) \\
16 &  \textbf{return }  result 
\end{aligned}
$$
注意：上述代码只是求出了最小生成树的权值，如果要输出方案还需要记录每个点的 𝑑𝑖𝑠![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "dis") 代表的是哪条边。