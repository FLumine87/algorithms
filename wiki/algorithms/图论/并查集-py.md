## 五、**并查集（Union-Find）数据结构**
### 1. **问题模型**
- 维护一个动态的集合划分，支持：
  - `make_group(x)`：创建单元素集合
  - `find(x)`：查询元素所在集合的代表元（leader）
  - `union(x, y)`：合并两个集合

### 2. **两种实现方式**
#### **方式一：序列实现**
- 每个元素存储其集合的 leader 引用。
- 合并时需更新所有元素的 leader，复杂度 $O(\min(|A|, |B|))$。

#### **方式二：树形实现**
- 每个集合用一棵树表示，根节点为 leader。
- `find` 需向上回溯至根。
- 优化手段：
  - **按秩合并（Union-by-Size）**：将小树合并到大树
  - **路径压缩（Path Compression）**：`find` 过程中将路径上所有节点直接连到根

### 3. **复杂度分析**
- 未优化：最坏 $O(n)$
- 优化后（按秩合并 + 路径压缩）：均摊 $O(\alpha(n))$，$\alpha(n)$ 是反阿克曼函数，近乎常数时间。
