## 一、图遍历的基本概念

### 1. 什么是图遍历？
- **遍历** 是一种系统性地探索图的方法，访问图中所有顶点和边。
- 若遍历能在 **线性时间**（即 \(O(n+m)\)）内完成，则称其为高效的。
- 图遍历算法是解决许多 **可达性** 相关问题的关键。

### 2. 可达性问题
- 寻找从 \(u\) 到 \(v\) 的路径（或判断是否存在）。
- 从起点 \(s\) 出发，找到到所有顶点的最短路径（边数最少）。
- 判断图是否连通。
- 计算连通分量。
- 检测图中是否存在环。

---

## 二、深度优先搜索

### 1. 基本思想
- 沿着一条路径尽可能深入，直到无法继续，然后回溯。
- 类似于 **回溯算法**：能进则进，不能进则退。

### 2. 递归过程
1. 从起始顶点开始，标记为已访问。
2. 递归地访问每一个未访问的邻接顶点。
3. 遇到死胡同则回溯到上一个顶点。

### 3. 边的分类
- **树边**：DFS 过程中发现新顶点的边。
- **前向边**：祖先指向后代（有向图中）。
- **后向边**：后代指向祖先。
- **交叉边**：非祖先-后代关系的边（仅在有向图中出现）。

### 4. DFS 的性质
- 在无向图中，DFS 会访问 **起始顶点所在连通分量** 的所有顶点，并生成该连通分量的一棵 **生成树**。
- 在有向图中，DFS 会访问从起点出发所有可达的顶点，并生成一棵 **DFS 树**，其中包含从起点到每个可达顶点的路径。

### 5. 时间复杂度
- DFS 对每个顶点和每条边最多访问一次：
  - 无向图：每条边最多访问两次（从两端）。
  - 有向图：每条边最多访问一次（从起点）。
- 总时间复杂度：\(O(n + m)\)。

### 6. 应用
- 寻找路径（`construct_path` 函数）。
- 判断连通性。
- 计算连通分量（`DFS_complete` 函数）。
- 检测环（存在后向边即有环）。

### 7. 实现细节
- 使用 **字典** 记录已访问顶点及其发现边。
- 递归实现（Code Fragment 14.5）。
- 可用于重建路径、检测连通性、找连通分量等。

---

## 三、广度优先搜索

### 1. 基本思想
- 按 **层次** 遍历图，先访问起点的所有邻接顶点，再逐层向外扩展。
- 使用队列辅助实现。

### 2. 过程描述
1. 起点 \(s\) 在第 0 层。
2. 访问第 \(i\) 层的所有顶点，将其未访问的邻接顶点放入第 \(i+1\) 层。
3. 重复直到没有新顶点。

### 3. BFS 的性质
- 访问从起点出发所有可达的顶点。
- 在 BFS 树中，从起点到任一顶点的路径是 **最短路径**（边数最少）。
- 非树边的两个顶点层级差不超过 1。

### 4. 时间复杂度
- 同样为 \(O(n + m)\)。

### 5. 实现
- 使用列表模拟队列，分层处理（Code Fragment 14.17）。
- 同样使用字典记录访问情况。

---

## 四、DFS 与 BFS 的对比

| 特性       | DFS                     | BFS                     |
|------------|--------------------------|--------------------------|
| 遍历方式   | 深度优先，递归/栈         | 广度优先，队列           |
| 适用问题   | 连通性、环检测、拓扑排序 | 最短路径、层级分析       |
| 空间复杂度 | 递归栈深 \(O(h)\)        | 队列大小 \(O(w)\)        |
| 边分类     | 四种（有向图）           | 主要用于树边和层间边     |
| 最短路径   | 不一定最短               | 保证最短（无权图）       |

