
## 一、最短路径问题概述
### 1. 两种最短路径
- **无权最短路径**：两个顶点之间边数最少的路径（可通过BFS求解）。
- **带权最短路径**：两个顶点之间总权重最小的路径（BFS无法直接求解）。

### 2. 负权边与负权环
- **负权边**：边的权重为负。
- **负权环**：一个环的总权重为负，会导致最短路径无限循环，使总权重趋于负无穷。
- **注意**：负权环不一定所有边都是负的，只要环的总权重为负即可。

---

## 二、Dijkstra算法（单源最短路径）
### 1. 适用条件
- **边权重非负**。
- 用于计算从起点到所有其他顶点的最短路径。

### 2. 核心思想
- 类似Prim算法，逐步扩展“云集”，每次选择离起点最近的未访问顶点加入云集。
- 使用**松弛操作**更新路径长度。

### 3. 数据结构
- `D[v]`：从起点到顶点v的最短路径估计值。
- `C`：已确定最短路径的顶点集合（云集）。
- 优先队列`Q`：按`D[v]`排序的未访问顶点。

### 4. 松弛操作
```
if D[u] + w(u,v) < D[v]:
    D[v] = D[u] + w(u,v)
```

### 5. 算法步骤
1. 初始化`D[s] = 0`，其他为`∞`。
2. 将所有顶点加入优先队列。
3. 循环直到队列为空：
   - 取出`D`值最小的顶点`u`。
   - 将`u`加入云集。
   - 对`u`的每个邻接点`v`执行松弛操作。

### 6. 正确性证明（归纳法）
- 每次加入云集的顶点，其`D`值即为最短路径长度。

### 7. 时间复杂度
- **堆实现**：`O((n+m)log n)`
- **无序列表实现**：`O(n²)`

### 8. 构建最短路径树
- 在松弛时记录每个顶点的前驱，可重建从起点到任意顶点的最短路径。

---

## 三、传递闭包
### 1. 定义
- 对于一个有向图`G`，其传递闭包`G*`是在`G`的基础上，若存在从`u`到`v`的路径，则在`G*`中添加边`(u,v)`。

### 2. 计算方法
- 对每个顶点执行BFS/DFS：`O(n(n+m))`
- 使用**Floyd-Warshall算法**：`O(n³)`

![[Pasted image 20260104223937.png]]
![[Pasted image 20260104223956.png]]

### 3. Floyd-Warshall算法（动态规划）
- 定义`d[i][j]^k`为经过顶点`v1…vk`从`i`到`j`的最短路径长度。
- 递推公式：
  ```
  d[i][j]^k = min(d[i][j]^{k-1}, d[i][k]^{k-1} + d[k][j]^{k-1})
  ```
- 初始化：`d[i][j]^0 = w(i,j)`
- 三重循环更新矩阵。

---

## 四、Floyd-Warshall算法（全源最短路径）
### 1. 适用性
- 可处理负权边，但不能有负权环。
- 适用于稠密图。

### 2. 算法步骤
```
for k from 1 to n:
    for i from 1 to n:
        for j from 1 to n:
            if d[i][k] + d[k][j] < d[i][j]:
                d[i][j] = d[i][k] + d[k][j]
```

### 3. 时间复杂度与空间复杂度
- 时间：`O(n³)`
- 空间：`O(n²)`（可原地更新）

---

## 五、Dijkstra与Floyd-Warshall对比
| 特性 | Dijkstra | Floyd-Warshall |
|------|----------|----------------|
| 问题类型 | 单源最短路径 | 全源最短路径 |
| 负权边 | 不支持 | 支持 |
| 负权环 | 不支持 | 不支持 |
| 时间复杂度 | `O((n+m)log n)` | `O(n³)` |
| 适用场景 | 稀疏图、正权图 | 稠密图、需所有顶点对距离 |

注：虽然说Dijkstra和prime在可视图中遍历相似，但有本质区别
- 前者有固定起点，并用权重实现云集（区别bfs，bfs用的是队列，而这里是优先队列以实现权重优先而不是距离优先），最终用贪心和松弛操作维护最短路径
- 后者每次只选择已选择集合T中延申的最小权重边，直到全部节点都在集合T中。无需像前者一样每个节点都要松弛操作。