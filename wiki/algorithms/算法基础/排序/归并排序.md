## 定义[](https://oi-wiki.org/basic/merge-sort/#%E5%AE%9A%E4%B9%89 "Permanent link")

归并排序（[merge sort](https://en.wikipedia.org/wiki/Merge_sort)）是高效的基于比较的稳定排序算法。

## 性质[](https://oi-wiki.org/basic/merge-sort/#%E6%80%A7%E8%B4%A8 "Permanent link")

归并排序基于分治思想将数组分段排序后合并，时间复杂度在最优、最坏与平均情况下均为 Θ(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\Theta (n \log n)")，空间复杂度为 Θ(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\Theta (n)")。

归并排序可以只使用 Θ(1)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\Theta (1)") 的辅助空间，但为便捷通常使用与原数组等长的辅助数组。

## 过程[](https://oi-wiki.org/basic/merge-sort/#%E8%BF%87%E7%A8%8B "Permanent link")

### 合并[](https://oi-wiki.org/basic/merge-sort/#%E5%90%88%E5%B9%B6 "Permanent link")

归并排序最核心的部分是合并（merge）过程：将两个有序的数组 `a[i]` 和 `b[j]` 合并为一个有序数组 `c[k]`。

从左往右枚举 `a[i]` 和 `b[j]`，找出最小的值并放入数组 `c[k]`；重复上述过程直到 `a[i]` 和 `b[j]` 有一个为空时，将另一个数组剩下的元素放入 `c[k]`。

为保证排序的稳定性，前段首元素小于或等于后段首元素时（`a[i] <= b[j]`）而非小于时（`a[i] < b[j]`）就要作为最小值放入 `c[k]`。

#### 实现[](https://oi-wiki.org/basic/merge-sort/#%E5%AE%9E%E7%8E%B0 "Permanent link")
```cpp
void merge(const int *a, size_t aLen, const int *b, size_t bLen, int *c) {
  size_t i = 0, j = 0, k = 0;
  while (i < aLen && j < bLen) {
    if (b[j] < a[i]) {  // <!> 先判断 b[j] < a[i]，保证稳定性
      c[k] = b[j];
      ++j;
    } else {
      c[k] = a[i];
      ++i;
    }
    ++k;
  }
  // 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中
  for (; i < aLen; ++i, ++k) c[k] = a[i];
  for (; j < bLen; ++j, ++k) c[k] = b[j];
}
```
也可使用 `<algorithm>` 库的 `merge` 函数，用法与上述指针式写法的相同。

### 分治法实现归并排序[](https://oi-wiki.org/basic/merge-sort/#%E5%88%86%E6%B2%BB%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F "Permanent link")

1. 当数组长度为 1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "1") 时，该数组就已经是有序的，不用再分解。
    
2. 当数组长度大于 1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "1") 时，该数组很可能不是有序的。此时将该数组分为两段，再分别检查两个数组是否有序（用第 1 条）。如果有序，则将它们合并为一个有序数组；否则对不有序的数组重复第 2 条，再合并。  

用数学归纳法可以证明该流程可以将一个数组转变为有序数组。

为保证排序的复杂度，通常将数组分为尽量等长的两段（𝑚𝑖𝑑 =⌊𝑙+𝑟2⌋![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "mid = \left\lfloor \dfrac{l + r}{2} \right\rfloor")）。

#### 实现[](https://oi-wiki.org/basic/merge-sort/#%E5%AE%9E%E7%8E%B0_1 "Permanent link")

注意下面的代码所表示的区间分别是 `[l, r)，[𝑙,𝑚𝑖𝑑),[mid, r)`。
```cpp
void merge_sort(int *a, int l, int r) {
  if (r - l <= 1) return;
  
  // 分解
  int mid = l + ((r - l) >> 1);
  merge_sort(a, l, mid);
  merge_sort(a, mid, r);
  
  // 合并 - 注意这里需要计算长度并匹配merge函数的接口
  // 方法1：使用固定大小数组（需要确保足够大）
  int tmp[1024] = {};  // 警告：可能不够用，建议使用动态分配
  
  // 正确调用merge函数
  merge(a + l, mid - l,  // 第一个数组：起始指针 + 长度
        a + mid, r - mid,  // 第二个数组：起始指针 + 长度
        tmp);  // 结果存放位置，从tmp[0]开始
  
  // 复制回原数组
  for (int i = 0; i < r - l; ++i) {
    a[l + i] = tmp[i];
  }
}
```