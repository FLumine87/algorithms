## 定义[](https://oi-wiki.org/basic/quick-sort/#%E5%AE%9A%E4%B9%89 "Permanent link")

快速排序（英语：Quicksort），又称分区交换排序（英语：partition-exchange sort），简称「快排」，是一种被广泛运用的排序算法。

## 基本原理与实现[](https://oi-wiki.org/basic/quick-sort/#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0 "Permanent link")

### 过程[](https://oi-wiki.org/basic/quick-sort/#%E8%BF%87%E7%A8%8B "Permanent link")

快速排序的工作原理是通过 [分治](https://oi-wiki.org/basic/divide-and-conquer/) 的方式来将一个数组排序。

快速排序分为三个过程：

1. 将数列划分为两部分（要求保证相对大小关系）；
2. 递归到两个子序列中分别进行快速排序；
3. 不用合并，因为此时数列已经完全有序。

和归并排序不同，第一步并不是直接分成前后两个序列，而是在分的过程中要保证相对大小关系。具体来说，第一步要是要把数列分成两个部分，然后保证前一个子数列中的数都小于后一个子数列中的数。为了保证平均时间复杂度，一般是随机选择一个数 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m") 来当做两个子数列的分界。

之后，维护一前一后两个指针 𝑝![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "p") 和 𝑞![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "q")，依次考虑当前的数是否放在了应该放的位置（前还是后）。如果当前的数没放对，比如说如果后面的指针 𝑞![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "q") 遇到了一个比 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m") 小的数，那么可以交换 𝑝![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "p") 和 𝑞![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "q") 位置上的数，再把 𝑝![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "p") 向后移一位。当前的数的位置全放对后，再移动指针继续处理，直到两个指针相遇。

其实，快速排序没有指定应如何具体实现第一步，不论是选择 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m") 的过程还是划分的过程，都有不止一种实现方法。

第三步中的序列已经分别有序且第一个序列中的数都小于第二个数，所以直接拼接起来就好了。

```cpp
//递归实现方式
template <typename T>
int Partition(T A[], int low, int high) {
  int pivot = A[low];
  while (low < high) {
    while (low < high && pivot <= A[high]) --high;
    A[low] = A[high];
    while (low < high && A[low] <= pivot) ++low;
    A[high] = A[low];
  }
  A[low] = pivot;
  return low;
}

template <typename T>
void QuickSort(T A[], int low, int high) {
  if (low < high) {
    int pivot = Partition(A, low, high);
    QuickSort(A, low, pivot - 1);
    QuickSort(A, pivot + 1, high);
  }
}

template <typename T>
void QuickSort(T A[], int len) {
  QuickSort(A, 0, len - 1);
}
```
## 性质[](https://oi-wiki.org/basic/quick-sort/#%E6%80%A7%E8%B4%A8 "Permanent link")

### 稳定性[](https://oi-wiki.org/basic/quick-sort/#%E7%A8%B3%E5%AE%9A%E6%80%A7 "Permanent link")

快速排序是一种不稳定的排序算法。

### 时间复杂度[](https://oi-wiki.org/basic/quick-sort/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6 "Permanent link")

快速排序的最优时间复杂度和平均时间复杂度为 𝑂(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n\log n)")，最坏时间复杂度为 𝑂(𝑛2)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n^2)")。

对于最优情况，每一次选择的分界值都是序列的中位数，此时算法时间复杂度满足的递推式为 𝑇(𝑛) =2𝑇(𝑛2) +Θ(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T(n) = 2T(\dfrac{n}{2}) + \Theta(n)")，由主定理，𝑇(𝑛) =Θ(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T(n) = \Theta(n\log n)")。

对于最坏情况，每一次选择的分界值都是序列的最值，此时算法时间复杂度满足的递推式为 𝑇(𝑛) =𝑇(𝑛 −1) +Θ(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T(n) = T(n - 1) + \Theta(n)")，累加可得 𝑇(𝑛) =Θ(𝑛2)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "T(n) = \Theta(n^2)")。

对于平均情况，每一次选择的分界值可以看作是等概率随机的。

在实践中，几乎不可能达到最坏情况，而快速排序的内存访问遵循局部性原理，所以多数情况下快速排序的表现大幅优于堆排序等其他复杂度为 𝑂(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n \log n)") 的排序算法。

## 优化[](https://oi-wiki.org/basic/quick-sort/#%E4%BC%98%E5%8C%96 "Permanent link")

### 朴素优化思想[](https://oi-wiki.org/basic/quick-sort/#%E6%9C%B4%E7%B4%A0%E4%BC%98%E5%8C%96%E6%80%9D%E6%83%B3 "Permanent link")

如果仅按照上文所述的基本思想来实现快速排序（或者是直接照抄模板）的话，那大概率是通不过 [P1177【模板】快速排序](https://www.luogu.com.cn/problem/P1177) 这道模板的。因为有毒瘤数据能够把朴素的快速排序卡成 𝑂(𝑛2)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n^2)")。

所以，我们需要对朴素快速排序思想加以优化。较为常见的优化思路有以下三种[2](https://oi-wiki.org/basic/quick-sort/#fn:ref3)。

- 通过 **三数取中（即选取第一个、最后一个以及中间的元素中的中位数）** 的方法来选择两个子序列的分界元素（即比较基准）。这样可以避免极端数据（如升序序列或降序序列）带来的退化；
- 当序列较短时，使用 **插入排序** 的效率更高；
- 每趟排序后，**将与分界元素相等的元素聚集在分界元素周围**，这样可以避免极端数据（如序列中大部分元素都相等）带来的退化。

下面列举了几种较为成熟的快速排序优化方式。

### 三路快速排序[](https://oi-wiki.org/basic/quick-sort/#%E4%B8%89%E8%B7%AF%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F "Permanent link")

#### 定义[](https://oi-wiki.org/basic/quick-sort/#%E5%AE%9A%E4%B9%89_1 "Permanent link")

三路快速排序（英语：3-way Radix Quicksort）是快速排序和 [基数排序](https://oi-wiki.org/basic/radix-sort/) 的混合。它的算法思想基于 [荷兰国旗问题](https://en.wikipedia.org/wiki/Dutch_national_flag_problem) 的解法。

#### 过程[](https://oi-wiki.org/basic/quick-sort/#%E8%BF%87%E7%A8%8B_1 "Permanent link")

与原始的快速排序不同，三路快速排序在随机选取分界点 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m") 后，将待排数列划分为三个部分：小于 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m")、等于 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m") 以及大于 𝑚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "m")。这样做即实现了将与分界元素相等的元素聚集在分界元素周围这一效果。

#### 性质[](https://oi-wiki.org/basic/quick-sort/#%E6%80%A7%E8%B4%A8_1 "Permanent link")

三路快速排序在处理含有多个重复值的数组时，效率远高于原始快速排序。其最佳时间复杂度为 𝑂(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n)")。

#### 实现[](https://oi-wiki.org/basic/quick-sort/#%E5%AE%9E%E7%8E%B0 "Permanent link")

三路快速排序实现起来非常简单，下面给出了一种三路快排的 C++ 实现。

```cpp
// 模板的 T 参数表示元素的类型，此类型需要定义小于（<）运算
template <typename T>
// arr 为需要被排序的数组，len 为数组长度
void quick_sort(T (&arr)[],const int start const int end) {//这里要特别注意，end是数组后一位
  if (end - start <= 1) return;
  // 随机选择基准（pivot）
  const T pivot = arr[start + rand() % (end - start)];
  //pivot = arr[random.randint(start, end)]
  // i：当前操作的元素下标
  // arr[0, j)：存储小于 pivot 的元素
  // arr[k, len)：存储大于 pivot 的元素
  int i = start, j = start, k = end;
  // 完成一趟三路快排，将序列分为：
  // 小于 pivot 的元素 | 等于 pivot 的元素 | 大于 pivot 的元素
  while (i < k) {
    if (arr[i] < pivot)
      swap(arr[i++], arr[j++]);
    else if (pivot < arr[i])
      swap(arr[i], arr[--k]);
    else
      ++i;
  }
  // 递归完成对于两个子序列的快速排序
  quick_sort(arr, start, j);
  quick_sort(arr, k, end);
}
```