
**在cpp中，这通常是指原始数组。**

数组是存放相同类型对象的容器，数组中存放的对象没有名字，而是要通过其所在的位置访问。数组的**大小是固定的**，不能随意改变数组的长度。

## 定义数组[](https://oi-wiki.org/lang/array/#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84 "Permanent link")

数组的声明形如 `a[d]`，其中，`a` 是数组的名字，`d` 是数组中元素的个数。在编译时，`d` 应该是已知的，也就是说，`d` 应该是一个整型的常量表达式。
```cpp
unsigned int d1 = 42; const int d2 = 42; int arr1[d1];  // 错误：d1 不是常量表达式
int arr2[d2];  // 正确：arr2 是一个长度为 42 的数组
```


不能将一个数组直接赋值给另一个数组：
```cpp
int arr1[3]; 
int arr2 = arr1;  // 错误 
arr2 = arr1; //错误
```

应该尽量将较大的数组定义为全局变量。因为局部变量会被创建在栈区中，过大（大于栈的大小）的数组会爆栈，进而导致 RE。如果将数组声明在全局作用域中，就会在静态区中创建数组。

### 越界访问下标[](https://oi-wiki.org/lang/array/#%E8%B6%8A%E7%95%8C%E8%AE%BF%E9%97%AE%E4%B8%8B%E6%A0%87 "Permanent link")

数组的下标 idx![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\mathit{idx}") 应当满足 0 ≤idx <size![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "0\leq \mathit{idx}< \mathit{size}")，如果下标不在这个范围内，则是未定义行为，会产生不可预料的后果，如段错误（Segmentation Fault），或者修改预期以外的变量等等。



### 数组操作
[[数组操作]]
[[数组操作-py]]
### 2.2 数组名与指针关系
```cpp
int arr[5] = {1, 2, 3, 4, 5};

// 数组名在大多数情况下退化为指向首元素的指针
cout << arr;        // 输出首元素地址
cout << &arr[0];    // 与上面等价

// 但仍有区别
cout << sizeof(arr);         // 输出: 20 (5*4字节)
cout << sizeof(&arr[0]);     // 输出: 8  (指针大小)

// 对数组名取地址
cout << &arr;                // 类型是 int(*)[5]，指向整个数组
cout << &arr + 1;            // 地址增加 5*sizeof(int)
```

## 三、多维数组

### 3.1 二维数组
```cpp
// 声明和初始化
int matrix1[3][4];  // 3行4列

// 初始化方式
int matrix2[2][3] = {
    {1, 2, 3},      // 第一行
    {4, 5, 6}       // 第二行
};

int matrix3[2][3] = {1, 2, 3, 4, 5, 6};  // 线性初始化

// C++11方式
int matrix4[][3] = {       // 可省略第一维
    {1, 2, 3},
    {4, 5, 6}
};
```

### 3.2 内存布局
即便是多维数组，地址仍然是连续的
```cpp
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
/*
按行存储的内存布局：
地址       值         访问
0x1000    1          matrix[0][0]
0x1004    2          matrix[0][1]
0x1008    3          matrix[0][2]
0x100C    4          matrix[1][0]
0x1010    5          matrix[1][1]
0x1014    6          matrix[1][2]

元素地址计算公式：
&matrix[i][j] = 数组首地址 + (i * cols + j) * sizeof(type)
*/
```

## 五、动态数组

### 5.1 使用 new/delete 创建动态数组
```cpp
// 1. 创建动态数组
int size = 10;
int* dynamicArray = new int[size];  // 分配内存

// 2. 初始化动态数组
for (int i = 0; i < size; ++i) {
    dynamicArray[i] = i * 2;
}

// 3. 访问元素
cout << dynamicArray[3];  // 输出: 6

// 4. 释放内存
delete[] dynamicArray;     // 必须使用 delete[]
dynamicArray = nullptr;    // 避免悬空指针

// 5. 多维动态数组
int rows = 3, cols = 4;
int** matrix = new int*[rows];      // 创建行指针数组
for (int i = 0; i < rows; ++i) {
    matrix[i] = new int[cols];      // 为每行创建数组
}

// 释放二维动态数组
for (int i = 0; i < rows; ++i) {
    delete[] matrix[i];
}
delete[] matrix;
```

### 10.2 内存对齐
```cpp
#include <iostream>

// 对齐的数组可以提升性能
alignas(64) int alignedArray[100];  // 64字节对齐

struct AlignedData {
    alignas(16) double values[4];  // 16字节对齐的double数组
};

int main() {
    // 检查对齐
    std::cout << "Alignment: " << alignof(alignedArray) << std::endl;
    return 0;
}
```
