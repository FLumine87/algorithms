

### 2. 动态数组的解决方案
- 维护两个关键属性：
  - `_n`：当前实际存储的元素个数
  - `_capacity`：底层数组的容量（最大可容纳元素数）
- 当 `_n == _capacity` 时，触发扩容

---

## 二、三种扩容策略及其时间复杂度分析

### 策略1：每次增加固定大小（如+1）

#### 操作过程
```
初始：capacity = 1
插入第2个元素：capacity = 2（复制1个元素）
插入第3个元素：capacity = 3（复制2个元素）
...
插入第n个元素：capacity = n（复制n-1个元素）
```

#### 时间复杂度分析
- 总复制次数 = 1 + 2 + 3 + ... + (n-1) = n(n-1)/2
- **时间复杂度：O(n²)**
- 问题：每次插入都可能导致复制，代价太高

### 策略2：几何级数扩容（如倍增）

#### 操作过程（以倍增为例）
```
初始：capacity = 1
插入第2个元素：capacity = 2（复制1个元素）      ← 触发扩容
插入第3个元素：capacity = 4（复制2个元素）      ← 触发扩容
插入第5个元素：capacity = 8（复制4个元素）      ← 触发扩容
...
插入第n个元素：capacity = 2^⌈log₂n⌉
```

#### 时间复杂度分析（摊还分析）
**关键观察**：只有在容量达到 2^k 时才触发扩容

**总复制次数计算**：
假设最终有 n 个元素，则：
- 最大容量 ≈ 2^⌈log₂n⌉ ≤ 2n
- 总复制次数 = 1 + 2 + 4 + ... + 2^(⌈log₂n⌉-1)
- 这是一个等比数列求和：
  $$
  S = \frac{2^{\lceil \log_2 n \rceil} - 1}{2-1} \approx 2^{\log_2 n} = n
  $$
- 更精确的上界：**总复制次数 < 2n**

**摊还分析结果**：
- 总操作次数（n次插入 + 复制）≈ 3n
- **每次插入的摊还时间复杂度 = O(1)**
- 空间利用率：至少 50%（因为扩容到2n时，实际有n个元素）

### 策略3：按比例扩容（如增加25%）

#### 操作过程
```
capacity = N → 新capacity = N + ⌈N/4⌉
例如：100 → 125 → 156 → 195 → ...
```

#### 时间复杂度分析
- 仍然是几何级数增长，只是增长率较小
- 等比数列的公比 r = 1.25
- 总复制次数 = n + n/r + n/r² + ... = n/(1 - 1/r) = O(n)
- **摊还时间复杂度仍然是 O(1)**
- 空间利用率更高（约80%），但扩容更频繁

---

## 三、摊还分析（Amortized Analysis）详解

### 1. 什么是摊还分析？
- 不是分析单次操作的最坏情况
- 而是分析**连续多次操作的平均代价**
- 类比：会计中的摊销——将大额开销分摊到多个期间

### 2. 应用于动态数组
- 单次 `append` 的最坏情况是 O(n)（触发扩容时）
- 但连续 n 次 `append` 的总时间是 O(n)
- 因此**每次 append 的摊还代价是 O(1)**

### 3. 两种常用的摊还分析方法

#### ① 聚集分析（Aggregate Analysis）
- 直接计算 n 次操作的总代价，然后除以 n
- 如我们刚才对倍增策略的分析：
  - n 次插入 + <2n 次复制 = O(n)
  - 平均每次插入 = O(1)

#### ② 记账方法（Accounting Method）
- 为每次简单操作收取"额外费用"作为信用
- 当昂贵操作发生时，用积累的信用支付
- 对于动态数组：
  - 每次插入收取 3 个"硬币"
  - 1个硬币用于实际插入
  - 2个硬币存为信用
  - 扩容时，用积累的信用支付复制成本

---

## 四、缩容策略

### 1. 为什么需要缩容？
- 如果只增不减，删除大量元素后会造成内存浪费
- 例如：插入100万个元素后删除99万个，容量可能还是100万

### 2. 课件中的缩容策略（C-5.16）
```python
def pop(self):
    if self._n == 0:
        raise IndexError("pop from empty array")
    value = self._A[self._n-1]
    self._n -= 1
    
    # 缩容条件：元素数小于容量的1/4
    if self._n < self._capacity // 4:
        self._resize(self._capacity // 2)
    return value
```

### 3. 缩容的时间复杂度分析
- 与扩容对称：当元素数降至容量1/4时，容量减半
- 保证空间利用率 ≥ 25%
- **摊仍分析**：连续 n 次 pop 操作的总时间也是 O(n)
- 避免"抖动"问题（频繁扩容缩容）

---

## 五、不同操作的时间复杂度总结

### 1. 基于索引的操作（O(1)）
- `data[j]`：获取元素
- `data[j] = val`：设置元素
- `len(data)`：获取长度

### 2. 末尾操作（摊还 O(1)）
- `append(value)`：追加
- `pop()`：删除末尾元素

### 3. 中间操作（O(n-k)）
- `insert(k, value)`：需要移动 k 之后的所有元素
- `pop(k)` / `del data[k]`：需要移动 k 之后的所有元素填补空缺
- `remove(value)`：需要查找并移动元素

---

### 3. 与其他数据结构的对比
| 操作 | 动态数组 | 链表 |
|------|----------|------|
| 随机访问 | O(1) | O(n) |
| 头部插入 | O(n) | O(1) |
| 尾部插入 | O(1)摊还 | O(1) |
| 中间插入 | O(n) | O(1)（已知位置） |
