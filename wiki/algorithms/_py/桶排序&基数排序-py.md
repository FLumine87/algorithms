## 四、桶排序（Bucket Sort）

### 1. 适用场景
适用于**键值为有限范围内的整数**（例如 \([0, N-1]\)）。

### 2. 基本思想
- 使用一个大小为 \(N\) 的桶数组 \(B\)。
- **计数阶段**：遍历序列，将每个元素放入对应的桶中。
- **收集阶段**：按顺序从桶中取出元素，得到有序序列。

### 3. 算法步骤
```python
def bucket_sort(S):
    B = [ [] for _ in range(N) ]  # 初始化桶数组
    for e in S:
        k = key(e)
        B[k].append(e)           # 放入对应桶中
    S.clear()
    for bucket in B:
        S.extend(bucket)         # 按顺序收集
```

### 4. 时间复杂度
- 计数阶段：\(O(n)\)
- 收集阶段：\(O(n + N)\)
- 总时间复杂度：**\(O(n + N)\)**

### 5. 稳定性问题
- 基本桶排序**不稳定**，因为相同键值的元素可能被任意顺序收集。
- 可通过**累积计数数组（Cumulative Count Array）**实现稳定排序（见课件第34-37页）。

---

## 五、基数排序（Radix Sort）

### 1. 适用场景
适用于**复合键（如字符串、多字段记录）**的排序。

### 2. 基本思想
- 从**最低有效位（或最次要键）**开始，依次进行稳定排序。
- 每次排序一个键位，最终得到全局有序序列。

### 3. 关键结论
- **必须从最低位（最次要键）开始排序**，否则最终结果可能不正确（见课件第40-41页示例）。
- 时间复杂度：\(O(d(n + N))\)，其中 \(d\) 是键的位数（或字段数），\(N\) 是每个键位的取值范围大小。

---

## 六、排序算法的比较与总结

| 算法 | 平均时间复杂度 | 最坏时间复杂度 | 是否稳定 | 适用场景 |
|------|----------------|----------------|----------|----------|
| 归并排序 | \(O(n \log n)\) | \(O(n \log n)\) | 是 | 通用、稳定排序需求 |
| 快速排序 | \(O(n \log n)\) | \(O(n^2)\) | 否 | 通用、原地排序 |
| 随机化快速排序 | \(O(n \log n)\) | \(O(n^2)\) | 否 | 避免最坏情况 |
| 桶排序 | \(O(n + N)\) | \(O(n + N)\) | 可稳定实现 | 整数键、范围小 |
| 基数排序 | \(O(d(n + N))\) | \(O(d(n + N))\) | 是 | 复合键、字符串 |

---
