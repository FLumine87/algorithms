## 一、搜索树的基本概念

### 1. 什么是有序映射？
有序映射是一种映射（键值对集合），其中键按照某种全序关系（如数字大小、字典序）排列，支持：
- 精确查找（key = k）
- 范围查询（key < k, key > k, key ≤ k, key ≥ k）
- 前驱/后继查找
- 最小/最大键查找

### 2. 为什么需要搜索树？
哈希表虽然查找快（O(1)），但**不保持键的顺序**。搜索树在保持有序性的同时，提供相对高效的查找性能（O(log n) 在平衡情况下）。

---

## 二、二叉搜索树（BST）

### 1. 定义
二叉搜索树是一棵**二叉树**，其中每个节点存储一个键值对 (k, v)，并满足以下**二叉搜索树性质**：
- 左子树中所有节点的键 < 当前节点的键
- 右子树中所有节点的键 > 当前节点的键
- 左右子树也都是二叉搜索树

```
示例：
       44
     /    \
   17      88
  /  \    /  \
 8   32  65  97
```

### 2. 性质与特性

#### （1）有序性
**命题 11.1**：二叉搜索树的**中序遍历**按键的升序访问所有节点。
#### （2）结构特性
- 任意节点的左子树只包含比它小的键
- 任意节点的右子树只包含比它大的键
- 没有重复键（通常约定）

---

## 三、BST 的基本操作

### 1. 查找（Search）

#### 算法思路：
从根开始，递归比较：
- 如果 `k == p.key`：找到，返回 p
- 如果 `k < p.key`：在左子树继续查找
- 如果 `k > p.key`：在右子树继续查找
- 如果到达空子树：查找失败

#### 递归实现（课件代码）：
```python
def TreeSearch(T, p, k):
    if k == p.key():
        return p                      # 成功找到
    elif k < p.key() and T.left(p) is not None:
        return TreeSearch(T, T.left(p), k)  # 递归左子树
    elif k > p.key() and T.right(p) is not None:
        return TreeSearch(T, T.right(p), k)  # 递归右子树
    return p                          # 失败，返回最后访问的节点
```

#### 迭代实现（更高效）：
```python
def TreeSearchIterative(T, p, k):
    current = p
    while current is not None:
        if k == current.key():
            return current
        elif k < current.key():
            current = T.left(current)
        else:
            current = T.right(current)
    return None  # 或返回最后一个非空节点
```

#### 时间复杂度：
- 最好/平均情况（树平衡）：O(log n)
- 最坏情况（树退化为链表）：O(n)

### 2. 插入（Insertion）

#### 算法步骤：
1. 执行查找操作，寻找键 k 应该插入的位置
2. 如果找到相同键，更新值（或报错，取决于实现）
3. 如果未找到，在查找终止的叶子节点处插入新节点

#### 示例：
```
插入键 20 到以下 BST：
       44
     /    \
   17      88
  /  \    /  
 8   32  65

查找路径：44 → 17 → 32
20 < 32 且 32 无左子，插入为 32 的左子：
       44
     /    \
   17      88
  /  \    /  
 8   32  65
     /
    20
```

### 3. 删除（Deletion）

删除操作最复杂，分为三种情况：

#### 情况1：删除叶子节点
直接删除，父节点对应指针置空。

#### 情况2：删除只有一个子节点的节点
用其子节点替代它。

#### 情况3：删除有两个子节点的节点
1. 找到该节点的**中序后继**（右子树的最小节点）
2. 用后继的键值替换要删除的节点
3. 删除后继节点（后继最多有一个右子，转为情况1或2）

#### 示例（删除有两个子节点的节点）：
```
删除键 17：
       44
     /    \
   17      88
  /  \    /  
 8   32  65
     /
    20

1. 找到 17 的后继：20（右子树的最小值）
2. 用 20 替换 17：
       44
     /    \
   20      88
  /  \    /  
 8   32  65
3. 删除原来的 20 节点（叶子节点）
```

---

## 四、BST 的导航操作

有序映射需要支持按顺序访问键，BST 提供以下导航方法：

### 1. 最值操作
- **first()**：返回最小键的节点
  - 从根开始，一直向左走，直到没有左子
- **last()**：返回最大键的节点
  - 从根开始，一直向右走，直到没有右子

### 2. 前驱与后继
- **before(p)**：返回键刚好小于 p.key 的节点
- **after(p)**：返回键刚好大于 p.key 的节点

#### 后继算法（课件代码）：
```python
def after(p):
    if right(p) is not None:
        # 后继在右子树的最小节点
        walk = right(p)
        while left(walk) is not None:
            walk = left(walk)
        return walk
    else:
        # 后继是最近的、p在其左子树中的祖先
        walk = p
        ancestor = parent(walk)
        while ancestor is not None and walk == right(ancestor):
            walk = ancestor
            ancestor = parent(walk)
        return ancestor
```

#### 前驱算法（对称）：
```python
def before(p):
    if left(p) is not None:
        # 前驱在左子树的最大节点
        walk = left(p)
        while right(walk) is not None:
            walk = right(walk)
        return walk
    else:
        # 前驱是最近的、p在其右子树中的祖先
        walk = p
        ancestor = parent(walk)
        while ancestor is not None and walk == left(ancestor):
            walk = ancestor
            ancestor = parent(walk)
        return ancestor
```

---

## 五、BST 的性能分析

### 1. 时间复杂度
所有基本操作（查找、插入、删除）的时间复杂度都取决于**树高 h**。

| 情况 | 树高 h | 操作时间复杂度 | 备注 |
|------|--------|----------------|------|
| 最好/平均（平衡） | O(log n) | O(log n) | 随机插入通常接近平衡 |
| 最坏（不平衡） | O(n) | O(n) | 插入有序序列会退化为链表 |

### 2. 空间复杂度
- 存储 n 个节点：O(n)
- 递归深度（最坏）：O(n)

---

## 六、BST 的局限性

### 1. 平衡性问题
- 插入顺序严重影响树的结构
- 有序插入（1, 2, 3, ...）会产生高度为 n 的链表
- 需要**平衡二叉搜索树**来解决

### 2. 平衡 BST 变种
- **AVL树**：严格的平衡条件，旋转操作多
- **红黑树**：宽松的平衡条件，实践中常用
- **B树/B+树**：多路搜索树，用于磁盘存储
- **Treap**：随机化平衡，实现简单

---

## 七、BST 与哈希表的比较

| 特性 | 二叉搜索树 | 哈希表 |
|------|-----------|--------|
| 有序性 | ✅ 支持 | ❌ 不支持 |
| 查找时间 | O(log n) ~ O(n) | O(1) ~ O(n) |
| 插入/删除时间 | O(log n) ~ O(n) | O(1) ~ O(n) |
| 内存使用 | 指针开销较大 | 数组+链表/探测 |
| 范围查询 | ✅ 高效 | ❌ 需要全表扫描 |
| 前驱/后继 | ✅ 支持 | ❌ 不支持 |
| 最坏情况 | 有序插入导致退化 | 所有键碰撞 |
