## 一、二叉搜索树（Binary Search Tree, BST）

### 1. 定义
- 二叉搜索树是一棵二叉树，每个节点存储一个键值对 \((k, v)\)。
- 对于任意节点 \(p\)：
  - 左子树中的所有键值小于 \(p\) 的键。
  - 右子树中的所有键值大于 \(p\) 的键。

### 2. 插入操作（Insertion）
- 从根节点开始，比较待插入键与当前节点键：
  - 若相等，更新该节点的值。
  - 若小于当前节点键，进入左子树。
  - 若大于当前节点键，进入右子树。
  - 直到找到一个空位置，插入新节点。

课件中给出的算法：
```python
Algorithm TreeInsert(T, k, v):
    p = TreeSearch(T, T.root(), k)
    if k == p.key():
        Set p’s value to v
    elif k < p.key():
        add node with item (k,v) as left child of p
    else:
        add node with item (k,v) as right child of p
```

### 3. 删除操作（Deletion）
分为三种情况：
1. **无子节点**：直接删除。
2. **有一个子节点**：删除节点，用其子节点替代。
3. **有两个子节点**：
   - 找到该节点左子树中的最大节点（前驱节点）或右子树中的最小节点（后继节点）。
   - 用该节点替代要删除的节点。
   - 删除原前驱/后继节点（此时该节点最多有一个子节点）。

### 4. 查找操作
- 从根节点开始，根据键值大小递归或迭代地查找。
- 若找到则返回节点，否则返回最后一个访问的节点。

### 5. 时间复杂度
- 所有基本操作（查找、插入、删除）的时间复杂度为 \(O(h)\)，其中 \(h\) 是树的高度。
- 最坏情况下（树退化为链表），\(h = n\)，操作复杂度为 \(O(n)\)。

### 6. 最坏情况示例
- 如果按递增或递减顺序插入节点，BST 会退化为一条链。

---

## 二、平衡搜索树（Balanced Search Trees）

### 1. 为什么需要平衡？
- 不平衡的 BST 可能导致操作效率降至 \(O(n)\)。
- 平衡操作（如旋转）可确保树的高度保持在 \(O(\log n)\)。

### 2. 旋转操作（Rotation）
- 通过旋转调整树的结构，保持平衡。
- 旋转分为左旋和右旋，时间复杂度为 \(O(1)\)。

#### 课件中的图示：
```
    y       右旋         x
   / \       ->        / \
  x   T3              T1  y
 / \       <-            / \
T1 T2      左旋         T2 T3
```

### 3. 三节点重构（Trinode Restructuring）
- 用于处理插入或删除后可能出现的失衡情况。
- 涉及三个节点：\(x\)、\(y\)（父节点）、\(z\)（祖父节点）。
- 通过一次或两次旋转恢复平衡。

---
