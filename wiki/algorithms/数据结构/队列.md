### 双栈模拟队列[](https://oi-wiki.org/ds/queue/#%E5%8F%8C%E6%A0%88%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97 "Permanent link")

还有一种冷门的方法是使用两个 [栈](https://oi-wiki.org/ds/stack/) 来模拟一个队列。

这种方法使用两个栈 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F") 和 𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 模拟一个队列，其中 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F") 是队尾的栈，𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 代表队首的栈，支持 push（在队尾插入），pop（在队首弹出）操作：

- push：插入到栈 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F") 中。
- pop：如果 𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 非空，让 𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 弹栈；否则把 𝐹![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "F") 的元素倒过来压到 𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 中（其实就是一个一个弹出插入，做完后是首尾颠倒的），然后再让 𝑆![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "S") 弹栈。

容易证明，每个元素只会进入/转移/弹出一次，均摊复杂度 𝑂(1)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(1)")。

[Luogu B3616【模板】队列](https://www.luogu.com.cn/problem/B3616) 双栈模拟参考实现

|   |
|---|
||

## C++ STL 中的队列[](https://oi-wiki.org/ds/queue/#c-stl-%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97 "Permanent link")

C++ 在 STL 中提供了一个容器 `std::queue`，使用前需要先引入 `<queue>` 头文件。

STL 中对 `queue` 的定义

|   |
|---|
|`// clang-format off template<     class T,     class Container = std::deque<T> > class queue;`|

`T` 为 queue 中要存储的数据类型。

`Container` 为用于存储元素的底层容器类型。这个容器必须提供通常语义的下列函数：

- `back()`
- `front()`
- `push_back()`
- `pop_front()`

STL 容器 `std::deque` 和 `std::list` 满足这些要求。如果不指定，则默认使用 `std::deque` 作为底层容器。

STL 中的 `queue` 容器提供了一众成员函数以供调用。其中较为常用的有：

- 元素访问
    - `q.front()` 返回队首元素
    - `q.back()` 返回队尾元素
- 修改
    - `q.push()` 在队尾插入元素
    - `q.pop()` 弹出队首元素
- 容量
    - `q.empty()` 队列是否为空
    - `q.size()` 返回队列中元素的数量

此外，`queue` 还提供了一些运算符。较为常用的是使用赋值运算符 `=` 为 `queue` 赋值，示例：

|   |
|---|
|`std::queue<int> q1, q2;  // 向 q1 的队尾插入 1 q1.push(1);  // 将 q1 赋值给 q2 q2 = q1;  // 输出 q2 的队首元素 std::cout << q2.front() << std::endl; // 输出: 1`|

## 特殊队列[](https://oi-wiki.org/ds/queue/#%E7%89%B9%E6%AE%8A%E9%98%9F%E5%88%97 "Permanent link")

### 双端队列[](https://oi-wiki.org/ds/queue/#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97 "Permanent link")

双端队列是指一个可以在队首/队尾插入或删除元素的队列。相当于是栈与队列功能的结合。具体地，双端队列支持的操作有 4 个：

- 在队首插入一个元素
- 在队尾插入一个元素
- 在队首删除一个元素
- 在队尾删除一个元素

数组模拟双端队列的方式与普通队列相同。

同样地，也可以使用双栈模拟队列的思想来维护双端队列，但需注意当某个栈为空时，交替查询队首和队尾将导致均摊分析失效。考虑在移动时，只将非空栈的一半元素移动到空栈中，并保持队首与队尾栈的性质，这样处理后仍可以做到均摊常数时间的插入和删除。

简要证明[Luogu B3656【模板】双端队列 1](https://www.luogu.com.cn/problem/B3656) 参考实现

|   |
|---|
||

#### C++ STL 中的双端队列[](https://oi-wiki.org/ds/queue/#c-stl-%E4%B8%AD%E7%9A%84%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97 "Permanent link")

C++ 在 STL 中也提供了一个容器 `std::deque`，使用前需要先引入 `<deque>` 头文件。

STL 中对 `deque` 的定义

|   |
|---|
||

STL 中的 `deque` 容器提供了一众成员函数以供调用。其中较为常用的有：

- 元素访问
    - `q.front()` 返回队首元素
    - `q.back()` 返回队尾元素
- 修改
    - `q.push_back()` 在队尾插入元素
    - `q.pop_back()` 弹出队尾元素
    - `q.push_front()` 在队首插入元素
    - `q.pop_front()` 弹出队首元素
    - `q.insert()` 在指定位置前插入元素（传入迭代器和元素）
    - `q.erase()` 删除指定位置的元素（传入迭代器）
- 容量
    - `q.empty()` 队列是否为空
    - `q.size()` 返回队列中元素的数量

此外，`deque` 还提供了一些运算符。其中较为常用的有：

- 使用赋值运算符 `=` 为 `deque` 赋值，类似 `queue`。
- 使用 `[]` 访问元素，类似 `vector`。

`<queue>` 头文件中还提供了优先队列 `std::priority_queue`，因其与 [堆](https://oi-wiki.org/ds/heap/) 更为相似，在此不作过多介绍。

#### Python 中的双端队列[](https://oi-wiki.org/ds/queue/#python-%E4%B8%AD%E7%9A%84%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97 "Permanent link")

在 Python 中，双端队列的容器由 `collections.deque` 提供。

示例如下：

实现

|   |
|---|
|`from collections import deque  # 新建一个 deque，并初始化内容为 [1, 2, 3] queue = deque([1, 2, 3])  # 在队尾插入元素 4 queue.append(4)  # 在队首插入元素 0 queue.appendleft(0)  # 访问队列 # >>> queue # deque([0, 1, 2, 3, 4])`|

### 循环队列[](https://oi-wiki.org/ds/queue/#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97 "Permanent link")

使用数组模拟队列会导致一个问题：随着时间的推移，整个队列会向数组的尾部移动，一旦到达数组的最末端，即使数组的前端还有空闲位置，再进行入队操作也会导致溢出（这种数组里实际有空闲位置而发生了上溢的现象被称为「假溢出」）。

解决假溢出的办法是采用循环的方式来组织存放队列元素的数组，即将数组下标为 0 的位置看做是最后一个位置的后继。（数组下标为 `x` 的元素，它的后继为 `(x + 1) % SIZE`）。这样就形成了循环队列。

## 参考资料[](https://oi-wiki.org/ds/queue/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99 "Permanent link")

1. [std::queue - zh.cppreference.com](https://zh.cppreference.com/w/cpp/container/queue)
2. [std::deque - zh.cppreference.com](https://zh.cppreference.com/w/cpp/container/deque)

---

> 本页面最近更新：2025/10/13 16:54:57，[更新历史](https://github.com/OI-wiki/OI-wiki/commits/master/docs/ds/queue.md)  
> 发现错误？想一起完善？ [在 GitHub 上编辑此页！](https://oi-wiki.org/edit-landing/?ref=/ds/queue.md "edit.link.title")  
> 本页面贡献者：[Ir1d](https://github.com/Ir1d), [abc1763613206](https://github.com/abc1763613206), [c-forrest](https://github.com/c-forrest), [iamtwz](https://github.com/iamtwz), [ksyx](https://github.com/ksyx), [leoleoasd](https://github.com/leoleoasd), [SourceDevKev](https://github.com/SourceDevKev), [Xeonacid](https://github.com/Xeonacid), [CCXXXI](https://github.com/CCXXXI), [cmpute](https://github.com/cmpute), [Enonya](https://github.com/Enonya), [Enter-tainer](https://github.com/Enter-tainer), [HeRaNO](https://github.com/HeRaNO), [kenlig](https://github.com/kenlig), [mcendu](https://github.com/mcendu), [mgt](mailto:i@margatroid.xyz), [NachtgeistW](https://github.com/NachtgeistW), [ouuan](https://github.com/ouuan), [qiaomo](https://github.com/qiaomo), [renbaoshuo](https://github.com/renbaoshuo), [sshwy](https://github.com/sshwy), [StudyingFather](https://github.com/StudyingFather), [Tiphereth-A](https://github.com/Tiphereth-A), [ttyao0518](https://github.com/ttyao0518)  
> 本页面的全部内容在 **[CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.zh) 和 [SATA](https://github.com/zTrix/sata-license)** 协议之条款下提供，附加条款亦可能应用

Copyright © 2016 - 2025 OI Wiki Team

Made with [Material for MkDocs

](https://squidfunk.github.io/mkdocs-material/)

[最近更新：00c6a264a, 2025-12-29](https://github.com/OI-wiki/OI-wiki)

已复制