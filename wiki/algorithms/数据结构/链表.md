### 内置函数
详见[[list]]

### 单向链表
```cpp
struct Node {
  int value;
  Node *next;
};
```

### 双向链表
```cpp
struct Node {
  int value;
  Node *left;
  Node *right;
};
```

#### 单链表插入
![[Pasted image 20251229214358.png]]
```cpp
void insertNode(int i, Node *p) {//尾插
  Node *node = new Node;
  node->value = i;
  node->next = p->next;
  p->next = node;
  //++size;
}
```

```cpp
void insertNode(int i, Node *h) {//尾插
  Node *node = new Node;
  node->value = i;
  node->next = h->next;
  h->next = node;
  //++size;
}
```

#### 单/双项循环链表插入
![[Pasted image 20251229215207.png]]
```cpp
void insertNode(int i, Node *p) {//单
  Node *node = new Node;
  node->value = i;
  node->next = NULL;
  if (p == NULL) {
    p = node;
    node->next = node;
  } else {
    node->next = p->next;
    p->next = node;
  }
}
```

```cpp
void insertNode(int i, Node *p) {//双
  Node *node = new Node;
  node->value = i;
  if (p == NULL) {
    p = node;
    node->left = node;
    node->right = node;
  } else {
    node->left = p;
    node->right = p->right;
    p->right->left = node;
    p->right = node;
  }
}
```

#### 单/双链表删除
![[Pasted image 20251229215502.png]]

```cpp
void deleteNode(Node *p) {//单
  p->value = p->next->value;
  Node *t = p->next;
  p->next = p->next->next;
  delete t;
}
```

```cpp
void deleteNode(Node *&p) {//双
  p->left->right = p->right;
  p->right->left = p->left;
  Node *t = p;
  p = p->right;
  delete t;
}
```



### 异或链表[](https://oi-wiki.org/ds/linked-list/#%E5%BC%82%E6%88%96%E9%93%BE%E8%A1%A8 "Permanent link")

>评价为有趣

异或链表（XOR Linked List）本质上还是 **双向链表**，但它利用按位异或的值，仅使用一个指针的内存大小便可以实现双向链表的功能。

我们在结构 `Node` 中定义 `lr = left ^ right`，即前后两个元素地址的 **按位异或值**。正向遍历时用前一个元素的地址异 或当前节点的 `lr` 可得到后一个元素的地址，反向遍历时用后一个元素的地址异或当前节点的 `lr` 又可得到前一个的元素地址。 这样一来，便可以用一半的内存实现双向链表同样的功能。