## 一、树的基本概念与定义

### 1. **树的定义**
- 除了根节点外，**每个节点都有一个父节点**和**零个或多个子节点**。
- 树可以是空的（没有节点）。

### 2. **关键术语**（只适用于有根树）
- **根（Root）**：没有父节点的节点。
- **叶节点（外部节点）**：没有子节点的节点。
- **内部节点**：至少有一个子节点的节点。

- **父亲（parent node）**：对于除根以外的每个结点，定义为从该结点到根路径上的第二个结点。  
    根结点没有父结点。
- **祖先（ancestor）**：一个结点到根结点的路径上，除了它本身外的结点。  
    根结点的祖先集合为空。
- **子结点（child node）**：如果 𝑢![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "u") 是 𝑣![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "v") 的父亲，那么 𝑣![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "v") 是 𝑢![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "u") 的子结点。  
    子结点的顺序一般不加以区分，二叉树是一个例外。
- **结点的深度（depth）**：到根结点的路径上的边数。
- **树的高度（height）**：所有结点的深度的最大值。
- **兄弟（sibling）**：同一个父亲的多个子结点互为兄弟。
- **后代（descendant）**：子结点和子结点的后代。  
    或者理解成：如果 𝑢![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "u") 是 𝑣![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "v") 的祖先，那么 𝑣![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "v") 是 𝑢![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "u") 的后代。
- **子树（subtree）**：删掉与父亲相连的边后，该结点所在的子图。
![[Pasted image 20251230170254.png]]

---

## 二、树的抽象数据类型（ADT）

课件中定义了一个基于**位置（Position）** 的树 ADT，提供了以下方法：

```python
T.root()          # 返回根节点位置
T.parent(p)       # 返回父节点
T.children(p)     # 返回子节点迭代器
T.is_leaf(p)      # 是否为叶节点
T.depth(p)        # 节点深度（递归计算）
T.height()        # 树的高度（可递归或迭代计算）
```

---

## 三、二叉树

### 1. **二叉树定义**
- 每个节点最多有两个子节点，分别称为**左子节点**和**右子节点**。
- 在节点的子节点顺序中，**左孩子位于右孩子的前一个位置**。
- 可以是**真二叉树（Proper Binary Tree）**：每个节点有 0 或 2 个子节点。
- 也可以是**非真二叉树（Improper Binary Tree）**。

### 2. **二叉树 ADT**
在树 ADT 基础上增加了：
- `T.left(p)`：返回左子节点
- `T.right(p)`：返回右子节点
- `T.sibling(p)`：返回兄弟节点

### 3. **二叉树的性质**
- 高度为 `h` 的二叉树最多有 `2^(h+1) - 1` 个节点。
- 真二叉树中：外部节点数 = 内部节点数 + 1（`n_E = n_I + 1`）。

### 3. **有序树**
- 每个节点的子节点有明确顺序（如第一、第二子节点）。

### 特殊的树
- **有根二叉树（rooted binary tree）**：每个结点最多只有两个儿子（子结点）的有根树称为二叉树。常常对两个子结点的顺序加以区分，分别称之为左子结点和右子结点。  
    大多数情况下，**二叉树** 一词均指有根二叉树。
    
- **完整二叉树（full/proper binary tree）**：每个结点的子结点数量均为 0 或者 2 的二叉树。换言之，每个结点或者是树叶，或者左右子树均非空。
    
    ![](https://oi-wiki.org/graph/images/tree-binary-proper.svg)
    
- **完全二叉树（complete binary tree）**：只有最下面两层结点的度数可以小于 2，且最下面一层的结点都集中在该层最左边的连续位置上。
    
    ![](https://oi-wiki.org/graph/images/tree-binary-complete.svg)
    
- **完美二叉树（perfect binary tree）**：所有叶结点的深度均相同，且所有非叶节点的子节点数量均为 2 的二叉树称为完美二叉树。
![](https://oi-wiki.org/graph/images/tree-binary-perfect.svg)


---

## 四、二叉树的实现

### 1. **链式存储结构（LinkedBinaryTree）**
- 每个节点包含：元素、父节点引用、左子节点引用、右子节点引用。
- 树对象维护根节点引用和节点总数。
- 支持的操作时间复杂度大多为 O(1)，如增删改节点。
![[Pasted image 20251230172733.png]]

### 2. **数组存储结构（Array-Based）**
- 通过**层编号（Level Numbering）** 将节点映射到数组下标：
1. 1-based：
- 左孩子：`x * 2` → `x << 1`
- 右孩子：`x * 2 + 1` → `(x << 1) + 1`
- 父节点：`x // 2` → `x >> 1`

2. 0-based：
- 左孩子：`x * 2 + 1` → `(x << 1) | 1` 或 `(x << 1) + 1`
- 右孩子：`x * 2 + 2` → `(x << 1) + 2` 或 `(x + 1) << 1`
- 父节点：`(x - 1) // 2` → `(x - 1) >> 1`

- **优点**：通过下标快速定位父子节点。
- **缺点**：可能浪费空间（特别是非完全二叉树）。
![[Pasted image 20251230172659.png]]

---

## 五、树的高度与深度计算

### 1. **深度（Depth）**
- 从根到该节点的路径长度（递归定义）。
- 实现方式：递归向上查找父节点。

### 2. **高度（Height）**
- 从节点到最远叶节点的路径长度。
- 可递归计算：`height(p) = 1 + max(height(child))`
---
## 遍历

1. 先序 按照 **根，左，右** 的顺序遍历二叉树。
```cpp
void preorder(BiTree* root) {
  if (root) {
    cout << root->key << " ";
    preorder(root->left);
    preorder(root->right);
  }
}
```
2. 中序 按照 **左，根，右** 的顺序遍历二叉树。
```cpp
void inorder(BiTree* root) {
  if (root) {
    inorder(root->left);
    cout << root->key << " ";
    inorder(root->right);
  }
}
```
3. 后续 按照 **左，右，根** 的顺序遍历二叉树。
```cpp
void postorder(BiTree* root) {
  if (root) {
    postorder(root->left);
    postorder(root->right);
    cout << root->key << " ";
  }
}
```

> 注意到，如果给出两中遍历，可以得出第三中遍历的顺序（数组顺序）
---
### 树上 BFS[](https://oi-wiki.org/graph/tree-basic/#%E6%A0%91%E4%B8%8A-bfs "Permanent link")

从树根开始，严格按照层次来访问节点。

BFS 过程中也可以顺便求出各个节点的深度和父亲节点。

#### 树的层序遍历[](https://oi-wiki.org/graph/tree-basic/#%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86 "Permanent link")

树层序遍历是指按照从根节点到叶子节点的层次关系，一层一层的横向遍历各个节点。根据 BFS 的定义可以知道，BFS 所得到的遍历顺序就是一种层序遍历。但层序遍历要求将不同的层次区分开来，所以其结果通常以二维数组的形式表示。

例如，下图的树的层序遍历的结果是 `[[1], [2, 3, 4], [5, 6]]`（每一层从左向右）。

![tree-basic-levelOrder](https://oi-wiki.org/graph/images/tree-basic-levelOrder.svg)
下面给出两个写法，其中后者更加全面，但本质一样
```cpp
void levelOrder(Node* root) {//这是逻辑实现
  queue<Node*> q;
  q.push(root);
  while (!q.empty()) {
	Node* cur = q.front();
	q.pop();
	for (Node* child : cur->children) {  // 把子节点都加入
	  q.push(child);
	}
  }
}
```

```cpp
vector<vector<int>> levelOrder(Node* root) {// 将树的的形式以二维数组的形式返回
  if (!root) {
    return {};
  }
  vector<vector<int>> res;
  queue<Node*> q;
  q.push(root);
  while (!q.empty()) {
    int currentLevelSize = q.size();  // 当前层的节点个数
    res.push_back(vector<int>());
    for (int i = 0; i < currentLevelSize; ++i) {
      Node* cur = q.front();
      q.pop();
      res.back().push_back(cur->val);
      for (Node* child : cur->children) {  // 把子节点都加入
        q.push(child);
      }
    }
  }
  return res;
}
```
--- 
## 一、符号说明

- $n$：树的总节点数（$n = n_E + n_I$）
- $n_E$：外部节点数（叶节点数）
- $n_I$：内部节点数（有至少一个子节点的节点数）
- $h$：树的高度（从根到最深叶节点的边数，或层数-1）
  - 注意：有的教材定义高度为节点数，这里是边数定义(这极有可能是教材的问题)

---

## 二、一般二叉树的性质（任何二叉树）

### **性质1：** $h+1 \leq n \leq 2^{h+1} - 1$

#### **下界 $h+1 \leq n$**
- **解释**：高度为 $h$ 的树至少有一条从根到叶的长度为 $h$ 的路径。
- 这条路径上有 $h+1$ 个节点（根+$h$ 个后代）。
- 因此节点数至少为 $h+1$。
- **极值情况**：退化成一条链（每个节点只有一个子节点）。

#### **上界 $n \leq 2^{h+1} - 1$**
- **解释**：高度为 $h$ 的**满二叉树**有最多的节点数。
- 满二叉树第 $k$ 层有 $2^k$ 个节点（根是第0层）。
- 总节点数 = $\sum_{k=0}^{h} 2^k = 2^{h+1} - 1$。
- **极值情况**：满二叉树。

---

### **性质2：** $1 \leq n_E \leq 2^h$

#### **下界 $n_E \geq 1$**
- **解释**：任何非空树至少有一个叶节点（即使是只有一个节点的树，根也是叶节点）。

#### **上界 $n_E \leq 2^h$**
- **解释**：叶节点最多出现在最底层（第 $h$ 层）。
- 第 $h$ 层最多有 $2^h$ 个节点，且这些节点都是叶节点。
- **极值情况**：满二叉树，所有叶节点都在第 $h$ 层。

---

### **性质3：** $h \leq n_I \leq 2^h - 1$

#### **下界 $n_I \geq h$**
- **解释**：高度为 $h$ 的树，从根到最深叶的路径上有 $h$ 个内部节点（除了叶节点外）。
- 即使是一条链，也有 $h$ 个内部节点（叶节点不算）。

#### **上界 $n_I \leq 2^h - 1$**
- **解释**：满二叉树时内部节点数最多。
- 满二叉树中，除了最底层的 $2^h$ 个叶节点外，其余都是内部节点。
- 总节点 $2^{h+1} - 1$，叶节点 $2^h$，所以内部节点 = $(2^{h+1} - 1) - 2^h = 2^h - 1$。

---

### **性质4：** $\log_2(n+1) - 1 \leq h \leq n-1$

#### **下界 $h \geq \log_2(n+1) - 1$**
- 从性质1的上界 $n \leq 2^{h+1} - 1$ 解出 $h$：
  $$
  n \leq 2^{h+1} - 1 \implies 2^{h+1} \geq n+1 \implies h+1 \geq \log_2(n+1) \implies h \geq \log_2(n+1) - 1
  $$
- **解释**：给定 $n$ 个节点，树的高度至少是这么多（完全二叉树接近这个下界）。

#### **上界 $h \leq n-1$**
- 从性质1的下界 $n \geq h+1$ 解出 $h \leq n-1$。
- **解释**：退化成链时，高度最大，为 $n-1$。

---

## 三、真二叉树（Proper Binary Tree）的性质

**真二叉树定义**：每个节点要么有0个子节点（叶节点），要么有2个子节点。

### **性质1（真二叉树）：** $2h+1 \leq n \leq 2^{h+1} - 1$

#### **下界 $n \geq 2h+1$**
- **证明**：真二叉树中，高度为 $h$ 时，节点数最少的情况是**完全倾斜的真二叉树**。
- 这种树的构造：根有一个子节点，该子节点再有一个子节点……直到深度 $h$，但每个内部节点必须有两个子节点。
- 具体来说：除了最深的路径外，每个内部节点还有一个额外的子节点（必须是叶节点）。
- 推导：
  - 高度 $h$ 的路径上有 $h+1$ 个节点。
  - 除了叶节点外，路径上的每个内部节点（共 $h$ 个）都有一个额外的叶节点。
  - 所以总节点数 = $(h+1) + h = 2h+1$。
- **示例**（h=3）：
  ```
        1
       / \
      2   3
     / \
    4   5
   / \
  6   7
  ```
  节点数 = 7 = 2×3+1。

#### **上界**：与一般二叉树相同（满二叉树）。

---

### **性质2（真二叉树）：** $h+1 \leq n_E \leq 2^h$

#### **下界 $n_E \geq h+1$**
- 在真二叉树中，叶节点数 ≥ 高度+1。
- 从下界构造（2h+1个节点）看：有 $h+1$ 个叶节点。
  - 路径上的叶节点：1个（最深）
  - 每个内部节点的额外叶节点：$h$ 个
  - 总计：$h+1$

#### **上界**：与一般二叉树相同。

---

### **性质3（真二叉树）：** $h \leq n_I \leq 2^h - 1$

#### **下界 $n_I \geq h$**
- 从下界构造看：内部节点数正好是 $h$（路径上的内部节点）。

#### **上界**：与一般二叉树相同。

---

### **性质4（真二叉树）：** $\log_2(n+1) - 1 \leq h \leq \frac{n-1}{2}$

#### **下界**：与一般二叉树相同。

#### **上界 $h \leq \frac{n-1}{2}$**
- 从下界 $n \geq 2h+1$ 解出：
  $$
  2h+1 \leq n \implies h \leq \frac{n-1}{2}
  $$
- **解释**：真二叉树的高度最大约为节点数的一半（对比一般二叉树可达 $n-1$）。

---

## 四、证明技巧与推导逻辑

### 1. **证明模板**
这些不等式的证明通常采用：
- **下界**：构造极端情况（如退化树、完全倾斜树）
- **上界**：引用满二叉树的性质（最大节点数）

### 2. **重要不等式链**
由性质1可推导其他性质：
$$
h+1 \leq n \leq 2^{h+1} - 1
$$
$$
\Downarrow
$$
$$
\log_2(n+1) - 1 \leq h \leq n-1
$$

### 3. **真二叉树的关键性质**
真二叉树有一个重要特性（Proposition 8.9）：
$$
n_E = n_I + 1
$$
由此可推出 $n = 2n_I + 1$ 或 $n = 2n_E - 1$，这个关系在推导真二叉树的性质时非常有用。

---

## 六、记忆技巧

### 1. **一般二叉树**
- **节点数范围**：$h+1$（链）到 $2^{h+1}-1$（满）
- **叶节点范围**：1（链）到 $2^h$（满）
- **高度范围**：$\log(n+1)-1$（完全）到 $n-1$（链）

### 2. **真二叉树**
- **节点数至少**：$2h+1$（倾斜真二叉树）
- **叶节点至少**：$h+1$
- **高度至多**：$(n-1)/2$

### 3. **满二叉树作为参考**
- 节点数：$2^{h+1} - 1$
- 叶节点：$2^h$
- 内部节点：$2^h - 1$
---
## 八、重要推论

从这些性质可以推出：

### 1. **平衡二叉树的高度**
对于有 $n$ 个节点的二叉树：
- 最坏情况（链）：$h = n-1$
- 最好情况（完全二叉树）：$h ≈ \log_2 n$
- 因此平衡二叉树操作的时间复杂度从 $O(n)$ 降到 $O(\log n)$

### 2. **叶节点比例的界限**
- 一般二叉树：叶节点比例在 $\frac{1}{n}$ 到 $\frac{2^h}{n}$ 之间
- 真二叉树：叶节点比例 ≥ $\frac{h+1}{2h+1} ≈ \frac{1}{2}$（对于大的 $h$）

---
*扩展*
## 二叉树 Morris 遍历[](https://oi-wiki.org/graph/tree-basic/#%E4%BA%8C%E5%8F%89%E6%A0%91-morris-%E9%81%8D%E5%8E%86 "Permanent link")

二叉树遍历的核心问题是，当遍历当前节点的子节点后，如何返回当前节点并继续遍历。遍历二叉树的递归方法和非递归方法都使用了栈结构，记录返回路径，来实现从下层到上层的移动。其空间复杂度最好时为 𝑂(log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(\log n)")，最坏时为 𝑂(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n)")（二叉树呈线性）。

Morris 遍历的实质是避免使用栈，利用底层节点空闲的 `right` 指针指回上层的某个节点，从而完成下层到上层的移动。

#### Morris 遍历的过程[](https://oi-wiki.org/graph/tree-basic/#morris-%E9%81%8D%E5%8E%86%E7%9A%84%E8%BF%87%E7%A8%8B "Permanent link")

假设来到当前节点 `cur`，开始时来到根节点位置。

1. 如果 `cur` 为空时遍历停止，否则进行以下过程。
2. 如果 `cur` 没有左子树，`cur` 向右移动（`cur = cur->right`）。
3. 如果 `cur` 有左子树，找到左子树上最右的节点，记为 `mostRight`。
    - 如果 `mostRight` 的 `right` 指针指向空，让其指向 `cur`，然后 `cur` 向左移动（`cur = cur->left`）。
    - 如果 `mostRight` 的 `right` 指针指向 `cur`，将其修改为 `null`，然后 `cur` 向右移动（`cur = cur->right`）。

例如，`cur` 从节点 1 开始访问。

![tree-basic-morris-1](https://oi-wiki.org/graph/images/tree-basic-morris-1.svg)

`cur` 第一次访问节点 2 时，找到左子树上最右的节点 4，将 4 的 `right` 指针指向 `cur`（节点 2)。

![tree-basic-morris-2](https://oi-wiki.org/graph/images/tree-basic-morris-2.svg)

`cur` 通过 4 的 `right` 指针返回上层，第二次访问节点 2 时，找到左子树上最右节点 4，将 4 的 `right` 指针修改为 `null`，然后继续访问右子树。之后的过程省略。

![tree-basic-morris-1](https://oi-wiki.org/graph/images/tree-basic-morris-1.svg)

整棵树的访问顺序是 `1242513637`。可以发现有左子树的节点访问两次，没有左子树的节点只访问一次。