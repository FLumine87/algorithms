## 结构[](https://oi-wiki.org/ds/binary-heap/#%E7%BB%93%E6%9E%84 "Permanent link")

从二叉堆的结构说起，它是一棵二叉树，并且是**完全二叉树**，每个结点中存有一个元素（或者说，有个权值）。

堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。

由堆性质，树根存的是最大值（getmax 操作就解决了）。

---
### 2. 堆的高度
- 若堆中有 n 个元素，则高度为 `h = ⌊log n⌋`。

---
## 过程[](https://oi-wiki.org/ds/binary-heap/#%E8%BF%87%E7%A8%8B "Permanent link")

### 插入操作[](https://oi-wiki.org/ds/binary-heap/#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C "Permanent link")

插入操作是指向二叉堆中插入一个元素，要保证插入后也是一棵完全二叉树。

最简单的方法就是，最下一层最右边的叶子之后插入。

如果最下一层已满，就新增一层。

插入之后可能会不满足堆性质？

**向上调整**：如果这个结点的权值大于它父亲的权值，就交换，重复此过程直到不满足或者到根。

可以证明，插入之后向上调整后，没有其他结点会不满足堆性质。

向上调整的时间复杂度是 𝑂(log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(\log n)") 的。

![二叉堆的插入操作](https://oi-wiki.org/ds/images/binary_heap_insert.svg)

### 删除操作[](https://oi-wiki.org/ds/binary-heap/#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C "Permanent link")

删除操作指删除堆中最大的元素，即删除根结点。

但是如果直接删除，则变成了两个堆，难以处理。

所以不妨考虑插入操作的逆过程，设法将根结点移到最后一个结点，然后直接删掉。

然而实际上不好做，我们通常采用的方法是，把根结点和最后一个结点直接交换。

于是直接删掉（在最后一个结点处的）根结点，但是新的根结点可能不满足堆性质……

**向下调整**：在**该结点的儿子中，找一个最大的**，与该结点交换，重复此过程直到底层。

可以证明，删除并向下调整后，没有其他结点不满足堆性质。

时间复杂度 𝑂(log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(\log n)")。

### 增加某个点的权值[](https://oi-wiki.org/ds/binary-heap/#%E5%A2%9E%E5%8A%A0%E6%9F%90%E4%B8%AA%E7%82%B9%E7%9A%84%E6%9D%83%E5%80%BC "Permanent link")

很显然，直接修改后，向上调整一次即可，时间复杂度为 𝑂(log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(\log n)")。

### 4. 时间复杂度

|操作|时间复杂度|
|---|---|
|`len()`, `is_empty()`|O(1)|
|`min()`|O(1)|
|`add()`|O(log n)|
|`remove_min()`|O(log n)|

## 实现[](https://oi-wiki.org/ds/binary-heap/#%E5%AE%9E%E7%8E%B0 "Permanent link")

我们发现，上面介绍的几种操作主要依赖于两个核心：向上调整和向下调整。

考虑使用一个序列 ℎ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "h") 来表示堆。ℎ𝑖![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "h_i") 的两个儿子分别是 ℎ2𝑖![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "h_{2i}") 和 ℎ2𝑖+1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "h_{2i+1}")，1![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "1") 是根结点：

![h 的堆结构](https://oi-wiki.org/ds/images/binary-heap-array.svg)

参考代码：
```cpp
void up(int x) {//注意，这里的数组从序号1开始
  while (x > 1 && h[x] > h[x / 2]) {
    std::swap(h[x], h[x / 2]);
    x /= 2;
  }
}

void down(int x) {
  while (x * 2 <= n) {
    t = x * 2;
    if (t + 1 <= n && h[t + 1] > h[t]) t++;
    if (h[t] <= h[x]) break;
    std::swap(h[x], h[t]);
    x = t;
  }
}
```

```cpp
void up(int x) {//注意，这里的数组从序号0开始
  while (x > 0 && h[x] > h[(x - 1) >> 1]) {
    std::swap(h[x], h[(x - 1) >> 1]);
    x = (x - 1) >> 1;
  }
}

void down(int x) {
  while ((x << 1) + 1 < n) {  // 左孩子存在
    int t = (x << 1) + 1;     // 左孩子索引
    if (t + 1 < n && h[t + 1] > h[t]) t++;  // 选择较大的子节点
    if (h[t] <= h[x]) break;
    std::swap(h[x], h[t]);
    x = t;
  }
}
```
### 建堆[](https://oi-wiki.org/ds/binary-heap/#%E5%BB%BA%E5%A0%86 "Permanent link")

考虑这么一个问题，从一个空的堆开始，插入 𝑛![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "n") 个元素，不在乎顺序。

直接一个一个插入需要 𝑂(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n \log n)") 的时间，有没有更好的方法？

#### 方法一：使用 decreasekey（即，向上调整）[](https://oi-wiki.org/ds/binary-heap/#%E6%96%B9%E6%B3%95%E4%B8%80%E4%BD%BF%E7%94%A8-decreasekey%E5%8D%B3%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4 "Permanent link")

从根开始，按 BFS 序进行。
```cpp
void build_heap_1() {
  for (i = 1; i <= n; i++) up(i);
}
```
为啥这么做：对于第 𝑘![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "k") 层的结点，向上调整的复杂度为 𝑂(𝑘)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(k)") 而不是 𝑂(log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(\log n)")。

总复杂度：log⁡1 +log⁡2 +⋯ +log⁡𝑛 =Θ(𝑛log⁡𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\log 1 + \log 2 + \cdots + \log n = \Theta(n \log n)")。

（在「基于比较的排序」中证明过）

#### 方法二：使用向下调整[](https://oi-wiki.org/ds/binary-heap/#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4 "Permanent link")

这时换一种思路，从叶子开始，逐个向下调整
```cpp
void build_heap_2() {
  for (i = n; i >= 1; i--) down(i);
}
```
换一种理解方法，每次「合并」两个已经调整好的堆，这说明了正确性。

注意到向下调整的复杂度，为 **𝑂(log⁡𝑛 −𝑘)**，另外注意到叶节点无需调整，因此可从序列约 𝑛/2![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "n/2") 的位置开始调整，可减少部分常数但不影响复杂度。

之所以能 𝑂(𝑛)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n)") 建堆，是因为堆性质很弱，二叉堆并不是唯一的。

要是像排序那样的强条件就难说了。

---
[[]]