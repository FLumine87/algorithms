## [[一些疑问]]
---
## [[逻辑门]]
---
## [[妙题]]
---
## 组合逻辑（Combinational Logic）和时序逻辑（Sequential Logic ）
1. **组合逻辑特点**
    - 输出由输入值决定，输入变，输出立刻按逻辑关系改变，无记忆功能。
    - 因无记忆，适合实现像算术运算（加法器可由组合逻辑构建，根据输入的加数、被加数得出和与进位 ）、数据选择（多路选择器，依据选择信号从多个输入中选一个输出 ）这类功能，输入实时决定输出，无需考虑历史状态。
2. **时序逻辑特点**
    - 输出依赖当前和之前的输入值，有短期记忆（靠存储元件实现 ）。
    - 常用于需要状态保持和顺序操作的场景，像寄存器（暂存数据，靠时序逻辑维持存储的数据 ）、状态机（如交通信号灯控制，不同灯亮的状态要依据之前状态和时间等输入切换 ），借助记忆功能实现复杂的时序控制和数据存储应用 。
#### Combinational logic（组合逻辑）

1. **构成规则含义**
    - **每个元件都是组合逻辑元件**：
    - **每个节点要么是输入，要么只连接一个输出**：
    - **电路不含循环路径（无来自之前状态 “记忆” 的反馈回路 ）**
---
## 一、Multiplexers（多路复用器，简称 MUX ）
1. ==**与译码器（Decoder）的反向功能**== 
2. **输入输出选择逻辑** 
3. **控制线路数量计算** 要从n个输入里选一个，==需要 $\log_2 n$ 条控制线路。==
4. **多路复用器的电路实现**
    - 用基本逻辑门（与门、或门、非门 ）搭建。以 2 选 1 多路复用器为例，输入$I_0$、$I_1$，控制信号S（$S = 0$选$I_0$，$S = 1$选$I_1$ ），输出Y，逻辑表达式是$Y = (\overline{S} \cdot I_0) + (S \cdot I_1)$ ，用一个非门产生$\overline{S}$，两个与门分别实现$\overline{S} \cdot I_0$和$S \cdot I_1$，再用或门把结果相加得到输出，复杂的多路复用器（如 4 选 1、8 选 1 ）可通过级联或扩展这种逻辑门组合方式实现 。
    - 现在也常用硬件描述语言（如 Verilog ）描述多路复用器，像 “module mux4to1 (input [3:0] I, input [1:0] S, output reg Y); always @(*) begin case (S) 2'b00: Y = I [0]; 2'b01: Y = I [1]; 2'b10: Y = I [2]; 2'b11: Y = I [3]; endcase end endmodule” ，通过 case 语句根据控制信号S选对应输入I的位输出，然后综合成实际电路，方便大规模数字系统设计 。
![[Pasted image 20250604225805.png]]
---
## 二、Demultiplexer（DEMUX，多路分配器 ）基础讲解
1. **核心功能**：是一种能将单一输入分配、传递到多个输出的电路 。和 MUX（多路复用器，“多对一” 选通 ）相反，DEMUX 实现 “一对多” 分配，比如把一路数据输入，根据控制信号选通到多个输出中的一个，像 1:4 DEMUX 就是把输入d分配到$y_0 - y_3$四个输出之一 。
2. **1:4 DEMUX 结构与控制**：以 1:4 DEMUX 为例，有 1 个数据输入d、2 个控制信号 $s_1$、$s_0$（因 $\log_2 4 = 2$，控制信号数量由输出数量决定，N输出需 $\log_2 N$ 控制信号 ）、4 个输出 $y_0 - y_3$ 。控制信号 $s_1$、$s_0$ 的不同组合（00、01、10、11 ），决定输入d被分配到哪个输出，如 $s_1s_0 = 00$ 时，d分配到 $y_0$；$s_1s_0 = 01$ 时，分配到 $y_1$ 等。
	![[Pasted image 20250605155608.png]] ![[Pasted image 20250605155626.png]]
---
## 时序电路
### 一、Timing（时序 ）幻灯片讲解

1. **电路延迟的存在**：电路中，输入变化到输出变化存在延迟，电路不是瞬时响应的 。
2. **延迟的测量标准**：测量延迟以输入和输出的 50% 电平跳变点为准，因为这是信号完成 “低→高” 或 “高→低” 转换的关键节点 。

### 二、Propagation and contamination delay（传播延迟与污染延迟 ）

1. **传播延迟（$t_{pd}$ ）**：是输入到输出的最大延迟
2. **污染延迟（$t_{cd}$ ）**：是输入到输出的最小延迟
![[Pasted image 20250605162951.png]]
### 三、延迟的成因与差异原因幻灯片讲解

1. **延迟的成因**：
    - **电路的电阻和电容**
    - **光速限制**
2. **$t_{pd}$和$t_{cd}$存在差异的原因**：
    - **上升沿和下降沿延迟不同**：
    - **多输入输出的差异**
    - **温度影响**
### 四、**关键路径（Critical Path）与短路径（Short Path）**
1. **关键路径（Critical Path）**：
    - 定义：电路中信号传输延迟最大的路径，决定了整个电路的最大延迟（即系统能运行的最高频率 ）。
    - 计算：图中关键路径是 $A/B \to \text{AND门} \to n1 \to \text{OR门} \to n2 \to \text{AND门} \to Y$ ==，延迟为== ==$t_{pd} = 2 \times t_{pd\_AND} + t_{pd\_OR}$==（经过 2 个与门、1 个或门的传播延迟之和 ）。
    - 影响：关键路径的延迟直接限制电路的工作速度，若想提高系统频率，必须优化关键路径（如减少逻辑门级数、更换更快的器件 ）。
2. **短路径（Short Path）**：
    - 定义：电路中信号传输延迟最小的路径，需关注其对电路时序约束的影响==（如避免信号提前到达引发亚稳态 ）==。
    - 计算：图中短路径是 $D \to \text{AND门} \to Y$ ，==延迟为== $t_{cd} = t_{cd\_AND}$（仅经过 1 个与门的污染延迟 ）。
    - 影响：短路径可能导致信号 “过早” 到达后续电路，若与其他路径信号时序不匹配，会引发竞争冒险（如输出毛刺 ），需通过时序约束或电路优化避免。
### 五、Sequential circuits（时序电路）基础讲解
1. **状态变化的时机**：时序电路状态变化仅在 “时钟触发”（clock ticks ）时发生，可在时钟的==上升沿==（信号从低到高跳变 ）、==下降沿==（从高到低跳变 ），或时钟脉冲达到最高电压时改变状态。不同的时序电路（如 D 触发器、JK 触发器 ）可配置为在不同时钟边沿触发，适配不同设计需求，比如高速电路常用上升沿触发以提升效率 。
2. 1. **时钟信号的关键参数**
    - **频率与周期**：频率决定电路工作速度（如 CPU 的 GHz 指标 ），周期是时钟信号重复一次的时间，与频率成反比（$T = 1/f$ ）。高频时钟能提升性能，但会增加功耗和电磁干扰（EMI ）。
    - **占空比**：时钟信号高电平时间占周期的比例，理想方波占空比 50%，但实际电路中因延迟可能偏离，影响时序均衡，比如某些 DDR 内存时钟的占空比会动态调整以优化数据传输 。
3. **时序电路的设计挑战**
    - **建立时间与保持时间**：建立时间是时钟沿到来前，输入信号需保持稳定的最小时间；保持时间是时钟沿到来后，输入信号需保持稳定的最小时间。若不满足，会导致亚稳态（输出不确定 ），是时序设计的核心约束。比如 FPGA 设计中，需严格约束输入输出的建立 / 保持时间，保障逻辑正确 。
    - **时钟 skew（偏移）与 jitter（抖动）**：时钟 skew 是不同电路模块时钟到达时间的差异，jitter 是时钟信号周期的随机变化，两者都会破坏时序同步，导致错误。在超大规模集成电路（如 GPU ）中，需通过时钟树综合（Clock Tree Synthesis ）和去抖电路优化，确保时钟信号的一致性 。
### 六、SR 电路
1. **反馈**（Feedback）**的作用**： 时序电路要 “记住” 自身状态，依赖**反馈**实现。反馈是指电路输出被 “loop back（环回）” 到输入，让电路能维持状态（如记住前一次的输出结果 ）。没有反馈，时序电路无法存储状态，只能像组合电路一样 “即时响应” 。
2. **双稳态电路（Bistable Circuit）**：
    - 是反馈应用的**最简单例子**：无外部输入（仅靠内部反馈 ），有两个输出 Q 和 $\overline{Q}$（互补 ）。
![[Pasted image 20250605165652.png]] ![[Pasted image 20250605165752.png]]
### 七、D Latch（D 锁存器）基础讲解

1. **核心结构与输入**： D 锁存器有两个关键输入：
    
    - **CLK（时钟）**：控制输出何时变化（相当于 “开关”，决定是否让数据通过 ）。
    - **D（数据）**：控制输出变化到什么值（要存储的数据 ）。 电路上，它由**与非门 / 或非门**（图中通过逻辑门组合，本质是在 SR 锁存器基础上改进 ）构成，解决了 SR 锁存器中 $S=1$、$R=1$ 的无效状态问题。
2. **工作模式（透明与不透明）**：
    
    - **当 $CLK = 1$（时钟有效 ）**：锁存器处于**透明模式**—— 数据 D 直接 “穿过” 锁存器，输出 $Q = D$（类似缓冲器，输入啥输出啥 ）。此时 $\overline{Q} = \overline{D}$，始终互补。
    - **当 $CLK = 0$（时钟无效 ）**：锁存器处于**不透明模式**—— 输出 Q 保持之前的值（无论 D 怎么变，Q 都不变 ），实现 “记忆” 功能。

#### 二、D Latch 工作原理（结合真值表）

看真值表（右侧表格 ）：
![[Pasted image 20250605170414.png]]

→ **结论**：D 锁存器通过时钟控制 “是否更新状态”，数据仅从 D 到 Q 单向传递，避免了 SR 锁存器的无效输入问题，更易用、稳定。

#### 三、拓展内容

1. **D Latch 的实际应用**
    - **数据暂存**：在 CPU 流水线中，D 锁存器用于**暂存中间数据**（如指令译码后的结果 ），确保时钟节拍内数据稳定，避免干扰。
    - **异步电路同步化**：将异步输入的信号（如按键、外部传感器 ）通过 D 锁存器 “打一拍”（用时钟同步 ），消除亚稳态，确保系统稳定。
2. **与 D 触发器（D Flip - Flop）的区别** D 锁存器是**电平敏感**（CLK 为 1 期间，D 变化会直接影响 Q ），而 D 触发器是**边沿敏感**（仅在时钟上升沿 / 下降沿瞬间采样 D，CLK 为 1 期间 D 变化不影响 Q ）。 → 触发器抗干扰能力更强，更适合高频同步电路（如 CPU 寄存器 ）；锁存器结构更简单，适合低速、低功耗场景（如简单 MCU 的 IO 口 ）。
---
### 八、 D Flip - Flop（D 触发器）基础讲解
#### 1. 结构：两个 D 锁存器的 “级联协作”
D 触发器由**两个背靠背的 D 锁存器（L1、L2 ）** 组成，受**互补时钟**控制（一个锁存器时钟为 CLK，另一个为 $\overline{CLK}$ ，通过反相器实现 ）。这种结构让它从 “电平敏感”（D 锁存器 ）升级为 “边沿敏感”（触发器 ）。
#### 2. 核心输入与符号
- **输入**：CLK（时钟 ）、D（数据 ）。
- **符号特征**：时钟端有**三角形标记**（区别于 D 锁存器的 “clk” 文字 ），表示 “边沿触发”。

![[Pasted image 20250605172300.png]]
### 九、Registers（寄存器）

#### 1. 核心定义

N 位寄存器是**N 个触发器的集合**，共享同一个时钟输入（CLK），确保寄存器的所有位在**同一时刻更新**。

- 比如 4 位寄存器（图中示例），由 4 个 D 触发器组成，输入 $D_{3:0}$（4 位数据 ），输出 $Q_{3:0}$（存储的 4 位数据 ）。
### 十、Flip - flop variants（触发器变体）

#### 1. Enabled Flip - Flop（使能触发器）

- **结构**：在普通 D 触发器基础上，增加**使能输入（EN）** → 三个输入：CLK、D、EN。
- **功能**：
    - $EN = 1$：时钟边沿到来时，D 传递到 Q（正常工作 ）。
    - $EN = 0$：无论 CLK 如何，触发器保持之前的状态（不更新 ）。
- **应用场景**：需要 “选择性更新” 数据时使用。例如，CPU 中某些寄存器仅在特定指令（如 “LOAD” ）执行时更新，其他时候保持原值。
![[Pasted image 20250605221655.png]]
#### 2. Resettable flip - flops（可复位触发器）

- **两种类型**：
    - **同步复位（Synchronous Reset）**：仅在**时钟边沿**到来时，若复位信号（Reset = 1 ），则触发器清零。
    - **异步复位（Asynchronous Reset）**：只要复位信号（Reset = 1 ），立即清零，**无需等待时钟边沿**。
- **设计影响**：异步复位需修改触发器内部电路（如在锁存器级增加复位逻辑 ），同步复位更易控制时序，但响应稍慢。
- **实际用例**：系统上电时，用异步复位快速将所有触发器清零；运行中，用同步复位确保复位操作与时钟同步（避免亚稳态 ）。
![[Pasted image 20250605221906.png]]
#### 3. Settable flip - flops（可置位触发器）

- **结构**：增加**置位输入（Set）** → 三个输入：CLK、D、Set。
- **功能**：
    - $Set = 1$：无论 D 和 CLK 如何，Q 直接置 1（强制设置为 1 ）。
    - $Set = 0$：触发器恢复为普通 D 触发器，按 CLK 边沿和 D 更新。
- **应用**：初始化电路状态（如系统启动时，将某寄存器置 1 ），或在故障恢复时强制设置特定值。
![[Pasted image 20250605221920.png]]
### 十一、触发器变体的 “设计哲学”与总结

所有变体（使能、复位、置位 ）都是为了**让触发器更灵活**，适配复杂系统的需求：

  

- 使能 → 控制 “何时更新”；
- 复位 → 控制 “何时清零”；
- 置位 → 控制 “何时置 1”。

  

这些变体组合起来，可构建高度定制化的时序电路。例如，一个带异步复位、同步使能的 D 触发器，能同时满足 “上电快速清零” 和 “运行时选择性更新” 的需求。

一句话概括：**寄存器 = 多个触发器 + 统一时钟**；**触发器变体 = 基础触发器 + 控制输入** → 它们共同支撑起数字系统的 “存储与控制” 功能。

---
### 十二、[[寄存器（Register）]]
### 十三、时序电路的总结
- **Register (or shift register)**：寄存器（或移位寄存器），是由触发器组成的数字电路，用于按顺序存储和移位数据 。比如在一些简单的数字系统中，可借助它暂存并传递数据。
- **Flip - Flop**：触发器，是能存储数据的基本单元，状态为 0 或 1 ，像常用的 D 触发器，就是数字电路里构建寄存器等结构的基础。
- **Parallel input**：并行输入，向并 - 并（PIPO）传输寄存器输入数据，数据同时上传到触发器，可让多个数据同时输入 ，比如在一些并行数据加载场景，能快速把多组数据存入寄存器。
- **Parallel output**：并行输出，从并 - 并（PIPO）关键寄存器输出，可访问触发器中存储的数据，能同时查看多个数据 ，例如在数据并行读取应用里，可一次性获取多组存储数据。
- **Serial input**：串行输入，是一种数据输入方式，数据逐位依次输入 ，比如在串行通信接口中，数据常以串行输入形式传输。
- **Serial output**：串行输出，从（寄存器等）电路提取数据的输出方式，数据逐位依次输出 ，像一些低速串行通信的输出阶段，会采用串行输出把数据逐位发送出去 。