
【Java Programming 复习提示】
1、继承关系//extends 只能继承一个

--子类 (subclass) 与父类 (superclass) 的声明、继承关键字 extends 的使用、静态成员（Static Members）
①封装(Encapsulation)access to private members of a class can be controlled via access modifiers
②抽象(Abstraction)classes,objects,methods and variables provide simple representations of complex underlying data and behavior.
③继承(Inheritance)inherited subclasses can be declared to share the attributes of the higher level superclasses.
④多态(Polymorphism)allows methods with the same name to work in different contexts.
Static 变量的特性

```java
    // 静态变量 - 所有对象共享
    private static int studentCount = 0;
    private static final String SCHOOL_NAME = "Java University"; // 静态常量
    
    // 静态代码块 - 类加载时执行一次
    static {
        System.out.println("Student class loaded.");
        // 可以进行复杂的静态初始化
    }
    
    public Student(String name) {
        this.name = name;
        this.id = ++studentCount; // 使用静态变量生成唯一ID
    }
    
    // 静态方法 - 只能访问静态成员
    public static int getStudentCount() {
        return studentCount;
        // 不能访问 this.name 或 name (非静态成员)
    }
        // 访问控制总结表：
        // 修饰符      类内   同包   子类   其他包
        // private     ✓     ✗     ✗     ✗
        // default     ✓     ✓     ✗     ✗
        // protected   ✓     ✓     ✓     ✗
        // public      ✓     ✓     ✓     ✓
```

2、注释语法
3、方法修饰符
--final 方法、
```java
    // final 变量 - 常量，必须初始化且不能修改
    public final int MAX_SPEED = 200;
    
    // final 方法 - 不能被子类重写
    public final void startEngine() {
        System.out.println("Engine started");
        performInitialCheck(); // 可以调用非final方法
    }
```
**synchronized** 方法（确保线程安全，同一时间仅允许一个线程执行）
3.1 实例方法
- **锁对象**: 当前实例对象(`this`)
- **影响范围**: 同一对象的所有`synchronized`实例方法
3.2 静态方法
- **锁对象**: 类的Class对象(`ClassName.class`)
- **影响范围**: 该类的所有`synchronized`静态方法
--访问控制（protected 访问修饰符允许同一包内及子类访问）


4、数组（Array）特性
--数组长度属性：array. Length (**数组是属性，字符串是方法**)
--数组索引：从 0 开始（零索引）
--数组异常：越界访问抛出 ArrayIndexOutOfBoundsException
--数组存储限制：元素类型必须一致


6、方法调用栈（Call Stack）
--LIFO（后进先出）原则：**最后调用的方法最先执行完毕**
7、递归（Recursion）
--基础情况（Base Case）的作用：提供终止条件防止无限递归

---
8、抽象类（Abstract Class）
```java
// 抽象类定义
public abstract class Animal {
    // 抽象方法：没有方法体，只有声明
    public abstract void makeSound();
    // 具体方法：有完整实现
    public void breathe() {
        System.out.println("呼吸中...");
    }
    // 可以有构造器
    public Animal() {
        System.out.println("Animal构造器被调用");
    }
    // 可以有成员变量
    private String name;
    // 可以有getter/setter
    public String getName() {
        return name;
    }
}
```
**关键理解**：
1. 抽象类的构造器**不是给自己用的**，而是给**子类用的**
2. 子类通过`super()`调用父类构造器来初始化继承的字段
3. 抽象类的构造器保证了**继承链的完整性**

--例如为什么不可实例化抽象类？It may contain abstract methods without implementation.

---
9、构造器（Constructor）
--构造器的作用**a constructor is to initialize an object's state when the object is created**
、this 关键字
10、接口（Interface）

```java
/**
 * 接口基础特性：
 * 1. 使用interface关键字定义
 * 2. 所有方法默认是public abstract（Java 8之前）
 * 3. 所有变量默认是public static final
 * 4. 一个类可以实现多个接口
 * 5. 接口可以继承多个接口
 */
public interface Animal {
    // 常量 - 默认是 public static final
    int MAX_AGE = 100;  // 等价于 public static final int MAX_AGE = 100;
```

```java
/**
 * 接口和抽象类的比较：
 * 
 * 相似点：
 * 1. 都不能被实例化
 * 2. 都可以包含抽象方法
 * 3. 都可以作为引用类型
 * 4. 都支持多态
 * 
 * 不同点：
 * 1. 接口只能有常量，抽象类可以有各种变量
 * 2. 接口方法默认public，抽象类方法可以是各种访问级别
 * 3. 类可以实现多个接口，但只能继承一个抽象类
 * 4. 接口不能有构造器，抽象类可以有
 * 5. 接口不能有实例方法（Java 8前），抽象类可以有
 * 
 * 使用选择：
 * 1. 需要多重继承 -> 接口
 * 2. 需要共享代码 -> 抽象类
 * 3. 定义行为契约 -> 接口
 * 4. 需要状态共享 -> 抽象类
 */
```
---
5、事件处理
--按钮点击事件接口：ActionListener
按钮点击事件接口：ActionListener:
实现ActionListener接口(重写actionPerformed(ActionEvent e) 方法)
给按钮添加时间监听器(btn.addActionListener(this))
```java
public class ButtonDemo extends JFrame implements ActionListener {  
        public ButtonDemo() {

JButton btn = new JButton(“click me!”);

btn.addActionListener(this); //__添加监听器_ _对象_

this.add(btn);  //__操作该对象_

this.setSize(300,200);

This.setVisible(true);

}//_除非该类是__abstract__类_
//__Java__语法规定__:__一个类实现接口的时候__,__必须重写接口中所有的抽象方法↑_

@Override 
public void actionPerformed(ActionEvent e) {

JOptionPane.showMessageDialog(frame, "Button Clicked!");

}

public static void main(String[] args) {

new ButtonDemo();

}
}
```
4. 验证事件绑定: 对于按钮点击等事件，需确认 3 点--是否创建事件监听器 (如 ActionListener)、监听器是否正确绑定到组件 (addActionListener 0)、监听器的核心方法 (如 actionPerformed ()
---
11、Swing vs AWT
--Swing 组件跨平台性：**外观与操作系统无关**

```text
               Component (AWT)
                    │
           ┌────────┴────────┐
           ▼                 ▼
      Container           JComponent (Swing)
           │                 │
    ┌──────┴──────┐    ┌─────┴─────┐
    ▼             ▼    ▼           ▼
Window     Panel       JButton   JLabel
    │         │
    ▼         ▼
Frame    Applet      JFrame    JPanel
                    (Swing)   (Swing)
```
属于继承关系，越下面越顶级
### 3.1 JFrame 基本结构

```java
import javax.swing.*; 
import java.awt.FlowLayout; 
public class JFrameDemo { public static void main(String[] args) { 
	// 方式1：构造器设标题 
	JFrame frame1 = new JFrame("直接设标题"); 
	// 方式2：setTitle设标题 
	JFrame frame2 = new JFrame(); 
	frame2.setTitle("动态设标题");
	
	// 1. 创建JFrame并设置基础属性 
	JFrame frame = new JFrame("GUI基础示例"); 
	frame.setSize(400, 200); // 宽400，高200
	rame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 关闭窗口退出程序 
	frame.setResizable(false); // 禁止缩放 
	frame.setLocationRelativeTo(null); // 居中 
	
	// 2. 设置布局（流式布局） 
	frame.setLayout(new FlowLayout()); 
	// 3. 创建并添加组件 
	JLabel tipLabel = new JLabel("点击按钮弹出提示："); 
	JButton clickBtn = new JButton("点我"); 
	// 给按钮加点击事件（可选，交互用） 
	clickBtn.addActionListener(e -> { JOptionPane.showMessageDialog(frame, "按钮被点击了！"); }); 
	frame.add(tipLabel); 
	frame.add(clickBtn); 
	// 4. 显示窗口（必须最后一步） 
	frame.setVisible(true); } }
```


### 3.2 默认关闭操作详解

**JFrame 关闭选项对比表**：

| 常量值                   | 数值  | 行为描述         | 使用场景         |     |
| --------------------- | --- | ------------ | ------------ | --- |
| `DO_NOTHING_ON_CLOSE` | 0   | 什么都不做，忽略关闭事件 | 需要自定义关闭逻辑    |     |
| `HIDE_ON_CLOSE`       | 1   | 隐藏窗口，程序继续运行  | 后台服务程序       |     |
| `DISPOSE_ON_CLOSE`    | 2   | 释放窗口资源       | 多窗口应用的子窗口    |     |
| `EXIT_ON_CLOSE`       | 3   | **退出整个应用程序** | **大多数单窗口应用** |     |

**实际应用示例**

11、方法重写（Overriding）与重载（Overloading）
--重写：子类修改父类方法（参数签名相同）occurs in inheritance when a subclass overrides a method of its parent class.
--重载：同一类中多个同名方法（参数列表不同）occurs in the same class when multiple methods have the same name but different parameter lists.

---
12、异常分类
--非受检异常（Unchecked Exception）：编译器不强制检查处理（如 RuntimeException）
```java
// Java异常类层次结构
Throwable (可抛出对象)
├── Error (错误) - 严重系统问题，不应捕获
│   ├── VirtualMachineError
│   ├── OutOfMemoryError
│   └── StackOverflowError
│
└── Exception (异常) - 应用程序可处理的异常
    ├── RuntimeException (运行时异常) - 非受检异常
    │   ├── NullPointerException
    │   ├── IndexOutOfBoundsException
    │   ├── IllegalArgumentException
    │   └── ArithmeticException
    │
    └── 其他Exception - 受检异常
        ├── IOException
        ├── SQLException
        ├── ClassNotFoundException
        └── InterruptedException
```

| 特性       | 受检异常 (Checked Exception)        | 非受检异常 (Unchecked Exception)                          |
| -------- | ------------------------------- | ---------------------------------------------------- |
| **检查时机** | 编译时 compile time                | 运行时                                                  |
| **处理要求** | 必须捕获或声明                         | 不强制处理                                                |
| **继承关系** | 继承Exception但不继承RuntimeException | 继承RuntimeException                                   |
| **设计目的** | 恢复性异常（可恢复的错误）                   | 编程错误（通常不可恢复）                                         |
| **示例**   | IOException, SQLException       | NullPointerException, ArrayIndexOutOfBoundsException |
| **最佳实践** | 捕获并处理或向上传播                      | 预防为主，避免发生                                            |

13、JVM 本质
--Java 虚拟机：软件层，非物理硬件

WORA

14、循环逻辑分析
--循环迭代中变量变化追踪
--条件分支对结果的影响
15、GUI 组件基础
--JFrame 标题设置、组件添加、默认关闭操作等
16、类设计原则
封装、参数校验等类的实现时的常用技巧
