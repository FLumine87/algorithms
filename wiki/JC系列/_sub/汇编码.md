[手把手教你学习汇编语言——从入门到起飞-CSDN博客](https://blog.csdn.net/weixin_46285416/article/details/116637114?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226c668613eaf5c94edde4402c63c33b3b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6c668613eaf5c94edde4402c63c33b3b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116637114-null-null.142^v102^control&utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4187)
[汇编语言快速入门（非常详细）-CSDN博客](https://blog.csdn.net/hanmo22357/article/details/127883179?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226c668613eaf5c94edde4402c63c33b3b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6c668613eaf5c94edde4402c63c33b3b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-127883179-null-null.142^v102^control&utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4187)
⤴️上面两个学到飞起来
[汇编语言指令大全_movaps-CSDN博客](https://blog.csdn.net/qq_33060405/article/details/144096575?ops_request_misc=%257B%2522request%255Fid%2522%253A%25226c668613eaf5c94edde4402c63c33b3b%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=6c668613eaf5c94edde4402c63c33b3b&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-144096575-null-null.142^v102^control&utm_term=%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80&spm=1018.2226.3001.4187)
⤴️适合中国宝宝体质
👇来財

| 汇编指令 | 功能描述                           | 示例                                                                                                             |
| ---- | ------------------------------ | -------------------------------------------------------------------------------------------------------------- |
| mov  | 将数据移动到寄存器                      | mov r0, #12：将立即数 12 移动到寄存器 r0                                                                                  |
| mul  | 乘法运算，将两个寄存器中的值相乘，结果存到目标寄存器     | mul r2, r0, r1：将 r0 和 r1 中的值相乘，结果存到 r2                                                                         |
| add  | 加法运算，将两个操作数相加，结果存到目标寄存器        | add r0, r5：将 r5 中的值加到 r0 中                                                                                     |
| sub  | 减法运算，用第一个操作数减去第二个操作数，结果存到目标寄存器 | sub r1, r4：用 r1 中的值减去 r4 中的值，结果存到 r1                                                                           |
| lsr  | 逻辑右移，将寄存器中的值右移指定的位数            | lsr r0, #1：将 r0 中的值右移 1 位                                                                                      |
| ldr  | 从内存加载数据到寄存器                    | ldr r1, =number：将 number 的地址加载到 r1<br>ldr r0, [r1]：从 r1 指向的内存地址加载数据到 r0<br>Ldr r 0, [r 1], #4 : 类迭代器，读取后，指向下一位 |
| str  | 将寄存器中的数据存储到内存                  | str r0, [r1]：将 r0 中的数据存储到 r1 指向的内存地址                                                                           |
| cmp  | 比较两个操作数                        | cmp r2, #0：比较 r2 和立即数 0                                                                                        |
| bne  | 条件分支指令，当不满足相等条件时跳转             | bne loop：如果不相等则跳转到 loop 标签                                                                                     |

## 好题

### 填空逻辑

1. **`Blank 1`**：MIPS 中调用函数需用 `jal`（跳转并链接，保存返回地址到 `$ra` ），所以填 `jal` ，用于调用 `differ` 函数。
2. **`Blank 2`**：程序结束前需跳转到退出点，通常用 `end` 标签，填 `end` 。
3. **`Blank 3`**：函数结束需用 `jr`（跳回调用处，依据 `$ra` 保存的返回地址 ）返回，填 `jr` 。
4. **`Blank 4`**：`jr` 需结合返回地址寄存器 `$ra` ，填 `ra` ，即 `jr $ra` 完成函数返回。
### 填空结果

- `Blank 1`：`jal`
- `Blank 2`：`end`
- `Blank 3`：`jr`
- `Blank 4`：`ra`

完整代码（填空后）：

```mips
main:
    addi $a0, $0, a
    addi $a1, $0, b
    jal differ        # Blank 1: 调用 differ 函数
    add $s0, $v0, $0
    j end             # Blank 2: 跳转到程序结束点
differ:
    sll $t0, $a0, 2
    sll $t1, $a1, 3
    sub $t2, $t0, $t1
    add $v0, $t2, $0
    jr $ra            # Blank 3 和 4: 函数返回，通过 $ra 回到调用处
end:
```


---
👇正经内容
#### 一、汇编语言的特性与定位

- **与高级语言的对比**：
    - **效率优势**：执行速度快、占用内存少、无需依赖库和操作系统。
    - **开发成本**：编写和调试耗时，且依赖特定架构（如 Intel i5 与三星八核处理器指令集不同）。
- **应用场景变迁**：
    - 1973 年因计算机内存和算力有限而普遍使用，2023 年仅在性能敏感或底层开发中使用（如嵌入式系统、驱动程序）。

#### 二、CPU 执行模型与指令编码

- **程序计数器（pc）**：
    - 每个时钟周期执行 pc 指向的内存指令，执行后自动递增指向下一条，分支指令可修改 pc 值。
- **寄存器作用**：
    - CPU 内置高速存储单元（如 r0-r15、sp 栈指针、pc 程序计数器），是内存层级中最快的存储。
- **指令编码示例（ARM 架构）**：
    - 32 位（4 字节）编码，例如 “r1 减 4 存到 r0” 的机器码需按操作码、条件码等字段组合。

#### 三、汇编程序设计基础

- **指令与机器码转换**：
    - 用助记符（如 mov、mul）替代二进制机器码，通过汇编器（Assembler）转换为可执行指令。
    - **示例程序**：计算 12×177 的汇编指令与对应机器码：
        
        assembly
        
        ```assembly
        mov r0, #12    ; 机器码11100011101000000000000000001100
        mov r1, #177   ; 机器码11100011101000000001000010110001
        mul r2, r0, r1 ; 机器码11100000000000100000000110010000
        ```
        
- **数学公式的汇编实现**：
    - 计算$S = \frac{(m+n)(n-m+1)}{2}$的步骤分解：
        1. 将 m 和 n 相加存到 r0（`add r0, r4, r5`）。
        2. n 减 m 存到 r1（`sub r1, r5, r4`），加 1（`add r1, #1`）。
        3. 乘积存 r0（`mul r0, r1`），右移 1 位实现除以 2（`lsr r0, #1`）。

#### 四、内存数据操作与指令

- **数据段定义（.data）**：
    - 用`.data`声明数据区，`.word`定义 4 字节（32 位）数据，标签（如`number`）对应内存地址。
    - **示例**：
        ```assembly
        .data
        number: .word 15  ; 15存储为32位二进制值
        ```
        
- **加载与存储指令（ldr/str）**：
    - `ldr r1, =number`：将`number`的地址存入 r1。
    - `ldr r0, [r1]`：读取 r1 指向的内存值到 r0。
    - `str r0, [r1]`：将 r0 的值写入 r1 指向的内存。
- **复合操作（加载后递增）**：
    - `ldr r2, [r1], #4`：读取 r1 地址的值到 r2，然后 r1 自增 4（指向下一元素）。
    - `str r2, [r1], #4`：将 r2 的值写入 r1 地址，然后 r1 自增 4。

#### 五、数组操作与循环实现

- **数组求和示例**：
    - 数组`nums`存储为`.word 10, 11, 12, 19, 0`（以 0 结尾），求和步骤：
        ```assembly
        mov r0, #0      ; 初始化和为0
        ldr r1, =nums   ; r1指向数组首地址
        loop:
            ldr r2, [r1], #4  ; 加载当前元素并移动指针
            add r0, r2       ; 累加
            cmp r2, #0       ; 检查是否为0（结束标志）
            bne loop         ; 非0则继续循环
        ```
        
- **内存布局与指针移动**：
    - 每个 `.word` 元素占 4 字节，指针每次递增 4 以访问下一个元素，通过 `cmp` 和 `bne` 实现条件循环。

#### 一、字符串的本质：ASCII 编码与数组表示

1. **ASCII 编码基础**
    
    - **定义**：ASCII 是一种将字符映射为 8 位数值的编码标准，每个字符对应唯一的 7 位或 8 位二进制数。
    - **示例**：字符串 "Hello" 的 ASCII 编码为：
        - 'H' → 72，'e' → 101，'l' → 108，'l' → 108，'o' → 111。
2. **字符串在汇编中的表示**
    
    - **字节数组形式**：

        ```assembly
        .data
        hello: .byte 72, 101, 108, 108, 111  ; 直接定义ASCII码值
        ```

    - **直接字符串定义**：
        ```assembly
        .data
        hello: .ascii "Hello"  ; 自动转换为对应ASCII码
        ```

    - **空终止字符串**：
        
        - 以 0 字节（ASCII 码 0）结尾，用于标记字符串结束，汇编中用`.asciz`定义：
        ```assembly
        .data
        hello: .asciz "Hello"  ; 等效于.byte 72,101,108,108,111,0
        ```
#### 二、字符串操作指令：字节级读写

1. **单字节加载指令（ldrb）**
    
    - **功能**：从内存读取单字节数据到寄存器。
    - **语法**：
        - `ldrb r2, [r1]`：读取 r1 地址的字节到 r2。
        - `ldrb r2, [r1], #1`：读取 r1 地址的字节到 r2，然后 r1 自增 1（指向下一字节）。
2. **单字节存储指令（strb）**
    
    - **功能**：将寄存器中的单字节数据写入内存。
    - **语法**：
        - `strb r2, [r1]`：将 r2 的字节数据写入 r1 地址。
        - `strb r2, [r1], #1`：写入数据后 r1 自增 1。
3. **大小写转换实例**
    
    - **原理**：小写字母比大写字母的 ASCII 码大 32（如 'a'-'A'=32）。
    - **伪代码逻辑**
        ```assembly
        loop:
            ldrb r0, [r1]      ; 加载当前字符
            cmp r0, #'a'       ; 检查是否为小写字母
            blt finish         ; 小于'a'则跳过（非小写）
            cmp r0, #'z'       ; 检查是否超过'z'
            bgt finish         ; 大于'z'则跳过
            sub r0, #32        ; 小写转大写（减32）
            strb r0, [r1], #1  ; 存储并移动指针
            b loop             ; 继续下一个字符
        finish:
        ```
#### 三、内存对齐：性能与兼容性关键

1. **未对齐数据的问题**
    
    - **现象**：若字符串占用非 4 字节边界（如 6 字节），后续 32 位数据（如`.word`）可能从非 4 的倍数地址开始，导致：
        - CPU 访问未对齐数据时产生异常或性能下降（部分架构不支持）。
2. **对齐指令（.align）**
    
    - **功能**：确保数据从指定的 2^n 字节边界开始。
    - **示例**：
        ```assembly
        .data
        .align 2            ; 2^2=4字节对齐
        nums: .word 10, 20  ; 确保nums从4的倍数地址开始
        ```
- **原理**：`.align n`表示对齐到 2^n 字节边界，n=2 即 4 字节对齐，避免未对齐访问。

#### 四、汇编字符串操作全流程示例

1. **字符串定义与加载**
    ```assembly
    .data
    .align 2            ; 4字节对齐
    message: .asciz "Hello, World!"  ; 空终止字符串
    result: .byte 0     ; 存储转换结果
    
    .text
    ldr r1, =message    ; r1指向字符串首地址
    ldr r2, =result     ; r2指向结果存储地址
    ```
    
2. **字符串处理循环**
    ```assembly
    loop:
        ldrb r0, [r1], #1  ; 加载字符并移动指针
        cmp r0, #0        ; 检查是否到字符串结尾（0）
        beq end           ; 是则结束
        ; 此处可添加字符处理逻辑（如大小写转换）
        strb r0, [r2], #1  ; 存储处理后的字符
        b loop            ; 继续下一个字符
    end:
    ```
#### 五、关键指令与伪指令总结

|**指令 / 伪指令**|**功能**|**示例**|
|---|---|---|
|`.ascii`|定义非空终止字符串，自动转为 ASCII 码|`.ascii "Hi"`|
|`.asciz`|定义空终止字符串（末尾加 0）|`.asciz "End"`|
|`.byte`|定义单字节数据|`.byte 65, 66`（'A','B'）|
|`ldrb/strb`|加载 / 存储单字节数据|`ldrb r0, [r1]` / `strb r0, [r1]`|
|`.align n`|数据对齐到 2^n 字节边界|`.align 2`（4 字节对齐）|

#### 六、内存布局与性能优化要点

1. **字符串存储结构**
    - 空终止字符串在内存中的布局：`"ABC"` → `0x41 0x42 0x43 0x00`（ASCII 码 + 终止符）。
2. **对齐优化原则**
    - 多字节数据（如`.word`）前使用`.align 2`，避免未对齐访问导致的性能损失。